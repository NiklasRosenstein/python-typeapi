{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"typeapi Typeapi provides a sane and stable API to introspect Python type hints. Installation $ pip install typeapi Quickstart import typing from typeapi import parse_type_hint print ( parse_type_hint ( typing . Any )) # Type(object) print ( parse_type_hint ( typing . List )) # Type(list) print ( parse_type_hint ( typing . Mapping [ str , int ])) # Type(collections.abc.Mapping, (Type(str), Type(int))) print ( parse_type_hint ( typing . Union [ str , int ])) # Union(int, str) print ( parse_type_hint ( str | int )) # Union(int, str) print ( parse_type_hint ( str | int | None )) # Optional(Union[int, str]) print ( parse_type_hint ( typing . Annotated [ int , 42 ])) # Annotated(int, 42) print ( parse_type_hint ( typing . Annotated [ int , 42 ])) # Annotated(int, 42) print ( parse_type_hint ( 'str' , __name__ )) # Type(str)","title":"Home"},{"location":"#typeapi","text":"Typeapi provides a sane and stable API to introspect Python type hints.","title":"typeapi"},{"location":"#installation","text":"$ pip install typeapi","title":"Installation"},{"location":"#quickstart","text":"import typing from typeapi import parse_type_hint print ( parse_type_hint ( typing . Any )) # Type(object) print ( parse_type_hint ( typing . List )) # Type(list) print ( parse_type_hint ( typing . Mapping [ str , int ])) # Type(collections.abc.Mapping, (Type(str), Type(int))) print ( parse_type_hint ( typing . Union [ str , int ])) # Union(int, str) print ( parse_type_hint ( str | int )) # Union(int, str) print ( parse_type_hint ( str | int | None )) # Optional(Union[int, str]) print ( parse_type_hint ( typing . Annotated [ int , 42 ])) # Annotated(int, 42) print ( parse_type_hint ( typing . Annotated [ int , 42 ])) # Annotated(int, 42) print ( parse_type_hint ( 'str' , __name__ )) # Type(str)","title":"Quickstart"},{"location":"api/typeapi.api/","text":"Class Hint class Hint () [view_source] Base for classes that represent type hints. Class Type @dataclasses . dataclass class Type ( Hint ) [view_source] Represents a concrete type, including type arguments if applicable. type The native Python type. Note that this may be types.NoneType if the type hint represented is None . args The type arguments, if applicable. This may yet contain type variables if that is what the original generic alias was created with. Class Union @dataclasses . dataclass class Union ( Hint ) [view_source] Represents typing.Union or typing.Optional . types The types in this union. Class Annotated @dataclasses . dataclass class Annotated ( Hint ) [view_source] Represents a type wrapped in typing.Annotated . wrapped The type that is annotated. metadata The metadata in the annotation. Class ForwardRef @dataclasses . dataclass class ForwardRef ( Hint ) [view_source] Represents a forward reference. expr The expression of the forward reference. module The module that is associated with the forward reference. Class Any @dataclasses . dataclass class Any ( Hint ) [view_source] Represents typing.Any . Class ClassVar @dataclasses . dataclass class ClassVar ( Hint ) [view_source] Represents typing.ClassVar . wrapped The inner type. Class Final @dataclasses . dataclass class Final ( Hint ) [view_source] Represents typing.Final . wrapped The inner type. Class NoReturn @dataclasses . dataclass class NoReturn ( Hint ) [view_source] Represents typing.NoReturn . Class TypeGuard @dataclasses . dataclass class TypeGuard ( Hint ) [view_source] Represents typing.TypeGuard . wrapped The wrapped type. Class Literal @dataclasses . dataclass class Literal ( Hint ) [view_source] Represents typing.Literal . values The possible values represented by the literal. Class NewType @dataclasses . dataclass class NewType ( Hint ) [view_source] Represents typing.NewType . name The name of the new type. supertype The underlying type for the new type. Class Unknown @dataclasses . dataclass class Unknown ( Hint ) [view_source] Represents an type hint that is not understood. hint The type hint that was not understood.","title":"typeapi.api"},{"location":"api/typeapi.api/#class-hint","text":"class Hint () [view_source] Base for classes that represent type hints.","title":"Class Hint"},{"location":"api/typeapi.api/#class-type","text":"@dataclasses . dataclass class Type ( Hint ) [view_source] Represents a concrete type, including type arguments if applicable.","title":"Class Type"},{"location":"api/typeapi.api/#type","text":"The native Python type. Note that this may be types.NoneType if the type hint represented is None .","title":"type"},{"location":"api/typeapi.api/#args","text":"The type arguments, if applicable. This may yet contain type variables if that is what the original generic alias was created with.","title":"args"},{"location":"api/typeapi.api/#class-union","text":"@dataclasses . dataclass class Union ( Hint ) [view_source] Represents typing.Union or typing.Optional .","title":"Class Union"},{"location":"api/typeapi.api/#types","text":"The types in this union.","title":"types"},{"location":"api/typeapi.api/#class-annotated","text":"@dataclasses . dataclass class Annotated ( Hint ) [view_source] Represents a type wrapped in typing.Annotated .","title":"Class Annotated"},{"location":"api/typeapi.api/#wrapped","text":"The type that is annotated.","title":"wrapped"},{"location":"api/typeapi.api/#metadata","text":"The metadata in the annotation.","title":"metadata"},{"location":"api/typeapi.api/#class-forwardref","text":"@dataclasses . dataclass class ForwardRef ( Hint ) [view_source] Represents a forward reference.","title":"Class ForwardRef"},{"location":"api/typeapi.api/#expr","text":"The expression of the forward reference.","title":"expr"},{"location":"api/typeapi.api/#module","text":"The module that is associated with the forward reference.","title":"module"},{"location":"api/typeapi.api/#class-any","text":"@dataclasses . dataclass class Any ( Hint ) [view_source] Represents typing.Any .","title":"Class Any"},{"location":"api/typeapi.api/#class-classvar","text":"@dataclasses . dataclass class ClassVar ( Hint ) [view_source] Represents typing.ClassVar .","title":"Class ClassVar"},{"location":"api/typeapi.api/#wrapped_1","text":"The inner type.","title":"wrapped"},{"location":"api/typeapi.api/#class-final","text":"@dataclasses . dataclass class Final ( Hint ) [view_source] Represents typing.Final .","title":"Class Final"},{"location":"api/typeapi.api/#wrapped_2","text":"The inner type.","title":"wrapped"},{"location":"api/typeapi.api/#class-noreturn","text":"@dataclasses . dataclass class NoReturn ( Hint ) [view_source] Represents typing.NoReturn .","title":"Class NoReturn"},{"location":"api/typeapi.api/#class-typeguard","text":"@dataclasses . dataclass class TypeGuard ( Hint ) [view_source] Represents typing.TypeGuard .","title":"Class TypeGuard"},{"location":"api/typeapi.api/#wrapped_3","text":"The wrapped type.","title":"wrapped"},{"location":"api/typeapi.api/#class-literal","text":"@dataclasses . dataclass class Literal ( Hint ) [view_source] Represents typing.Literal .","title":"Class Literal"},{"location":"api/typeapi.api/#values","text":"The possible values represented by the literal.","title":"values"},{"location":"api/typeapi.api/#class-newtype","text":"@dataclasses . dataclass class NewType ( Hint ) [view_source] Represents typing.NewType .","title":"Class NewType"},{"location":"api/typeapi.api/#name","text":"The name of the new type.","title":"name"},{"location":"api/typeapi.api/#supertype","text":"The underlying type for the new type.","title":"supertype"},{"location":"api/typeapi.api/#class-unknown","text":"@dataclasses . dataclass class Unknown ( Hint ) [view_source] Represents an type hint that is not understood.","title":"Class Unknown"},{"location":"api/typeapi.api/#hint","text":"The type hint that was not understood.","title":"hint"},{"location":"api/typeapi.deconstruct/","text":"Deconstruct concrete types and aliases. Class TypeInfo class TypeInfo ( t . NamedTuple ) [view_source] Contains information about a type hint that is either a fixed type or an alias (i.e. a parametrized type). origin The original Python type underlying the type hint. nparams The number of type parameters that the origin type accepts. parameters The type variables from the origin type's original definition. Note that this may be None even if nparams is greater than zero. This is usually the case for special generic aliases like typing.List for which no explicit type variables are defined in the typing module. args The type arguments that the origin was parametrized with. This is None if the type is not explicitly parametrized. It may still contain typing.TypeVars if that is what the type was parametrized with. with_args def with_args ( args : t . Tuple [ TypeArg , ... ]) -> TypeInfo [view_source] Return a copy of the TypeInfo object, but args replaced by the args parameter value. deconstruct_type def deconstruct_type ( type_ : t . Any ) -> TypeInfo [view_source] Deconstruct a type hint that is not a typing \"special form\" or another type of exotic hint, i.e. a hint that an actual singular type, and return its TypeInfo . Arguments : type_ any - The type hint to deconstruct. Raises : ValueError - If the type_ parameter cannot be deconstructed into a TypeInfo . For example, passing a typing.Annotated object or typing.ClassVar will cause this error to be raised. Example : import collections.abc import typing from typeapi.deconstruct import deconstruct_type , TypeInfo T = typing . TypeVar ( 'T' ) assert deconstruct_type ( typing . Any ) == TypeInfo ( object , 0 , None , None ) assert deconstruct_type ( typing . List ) == TypeInfo ( list , 1 , None , None ) assert deconstruct_type ( t . Mapping [ str , int ]) == TypeInfo ( collections . abc . Mapping , 2 , None , ( str , int ,)) class MyGeneric ( t . Generic [ T ]): pass assert deconstruct_type ( MyGeneric ) == TypeInfo ( MyGeneric , 1 , ( T ,), None ) assert deconstruct_type ( MyGeneric [ int ]) == TypeInfo ( MyGeneric , 1 , ( T ,), ( int ,)) assert deconstruct_type ( MyGeneric [ T ]) == TypeInfo ( MyGeneric , 1 , ( T ,), ( T ,))","title":"typeapi.deconstruct"},{"location":"api/typeapi.deconstruct/#class-typeinfo","text":"class TypeInfo ( t . NamedTuple ) [view_source] Contains information about a type hint that is either a fixed type or an alias (i.e. a parametrized type).","title":"Class TypeInfo"},{"location":"api/typeapi.deconstruct/#origin","text":"The original Python type underlying the type hint.","title":"origin"},{"location":"api/typeapi.deconstruct/#nparams","text":"The number of type parameters that the origin type accepts.","title":"nparams"},{"location":"api/typeapi.deconstruct/#parameters","text":"The type variables from the origin type's original definition. Note that this may be None even if nparams is greater than zero. This is usually the case for special generic aliases like typing.List for which no explicit type variables are defined in the typing module.","title":"parameters"},{"location":"api/typeapi.deconstruct/#args","text":"The type arguments that the origin was parametrized with. This is None if the type is not explicitly parametrized. It may still contain typing.TypeVars if that is what the type was parametrized with.","title":"args"},{"location":"api/typeapi.deconstruct/#with_args","text":"def with_args ( args : t . Tuple [ TypeArg , ... ]) -> TypeInfo [view_source] Return a copy of the TypeInfo object, but args replaced by the args parameter value.","title":"with_args"},{"location":"api/typeapi.deconstruct/#deconstruct_type","text":"def deconstruct_type ( type_ : t . Any ) -> TypeInfo [view_source] Deconstruct a type hint that is not a typing \"special form\" or another type of exotic hint, i.e. a hint that an actual singular type, and return its TypeInfo . Arguments : type_ any - The type hint to deconstruct. Raises : ValueError - If the type_ parameter cannot be deconstructed into a TypeInfo . For example, passing a typing.Annotated object or typing.ClassVar will cause this error to be raised. Example : import collections.abc import typing from typeapi.deconstruct import deconstruct_type , TypeInfo T = typing . TypeVar ( 'T' ) assert deconstruct_type ( typing . Any ) == TypeInfo ( object , 0 , None , None ) assert deconstruct_type ( typing . List ) == TypeInfo ( list , 1 , None , None ) assert deconstruct_type ( t . Mapping [ str , int ]) == TypeInfo ( collections . abc . Mapping , 2 , None , ( str , int ,)) class MyGeneric ( t . Generic [ T ]): pass assert deconstruct_type ( MyGeneric ) == TypeInfo ( MyGeneric , 1 , ( T ,), None ) assert deconstruct_type ( MyGeneric [ int ]) == TypeInfo ( MyGeneric , 1 , ( T ,), ( int ,)) assert deconstruct_type ( MyGeneric [ T ]) == TypeInfo ( MyGeneric , 1 , ( T ,), ( T ,))","title":"deconstruct_type"},{"location":"api/typeapi.parser/","text":"parse_type_hint @t . overload def parse_type_hint ( hint : t . Any ) -> Hint [view_source] Parse the given type hint to a Hint object. If the type hint is not accepted by any of the handlers, an instance of Unknown is returned instead. Arguments : hint - The type hint to adapt. Returns : A Hint object that should make it easier to introspect the type hint with a stable API. parse_type_hint @t . overload def parse_type_hint ( hint : t . Any , * , debug : te . Literal [ True ]) -> t . Tuple [ Hint , t . Optional [ str ]] [view_source] Same as parse_type_hint() , but returns the name of the handler function that accepted the type hint and converted it to a Hint object.","title":"typeapi.parser"},{"location":"api/typeapi.parser/#parse_type_hint","text":"@t . overload def parse_type_hint ( hint : t . Any ) -> Hint [view_source] Parse the given type hint to a Hint object. If the type hint is not accepted by any of the handlers, an instance of Unknown is returned instead. Arguments : hint - The type hint to adapt. Returns : A Hint object that should make it easier to introspect the type hint with a stable API.","title":"parse_type_hint"},{"location":"api/typeapi.parser/#parse_type_hint_1","text":"@t . overload def parse_type_hint ( hint : t . Any , * , debug : te . Literal [ True ]) -> t . Tuple [ Hint , t . Optional [ str ]] [view_source] Same as parse_type_hint() , but returns the name of the handler function that accepted the type hint and converted it to a Hint object.","title":"parse_type_hint"},{"location":"api/typeapi.utils/","text":"Provides utilities to introspect typing type hints. The goal is to assign the same semantics to all viable members of the typing module independent of the Python version. is_generic def is_generic ( hint : t . Any ) -> te . TypeGuard [ t . Type [ Generic ]] [view_source] Returns : True if hint is a subclass fo typing.Generic (and not an alias of it). is_generic_alias def is_generic_alias ( hint : t . Any ) -> te . TypeGuard [ GenericAlias ] [view_source] Returns : True if hint is a typing._GenericAlias or types.GenericAlias ( PEP 585 since Python 3.10+). !!! note In Python versions 3.8 and older, typing._GenericAlias is used also for special generic aliases (see is_special_generic_alias() ). This function will return False for these types of aliases to clearly distinct between special aliases and normal aliases, even if they share the same type. is_union_type def is_union_type ( hint : t . Any ) -> te . TypeGuard [ UnionType ] [view_source] Returns : True if hint is a typing.Union or types.UnionType . is_special_generic_alias def is_special_generic_alias ( hint : t . Any ) -> te . TypeGuard [ SpecialGenericAlias ] [view_source] Returns : True if hint is a typing._SpecialGenericAlias (like typing.List or typing.Mapping ). !!! note For Python versions 3.8 and older, the function treats typing._GenericAliases as special if their _special attribute is set to True . typing._SpecialGenericAlias was introduced in Python 3.9. is_special_form def is_special_form ( hint : t . Any ) -> te . TypeGuard [ SpecialGenericAlias ] [view_source] Returns : True if hint is a typing._SpecialForm (like typing.Final or typing.Union ). is_annotated_alias def is_annotated_alias ( hint : t . Any ) -> te . TypeGuard [ AnnotatedAlias ] [view_source] Returns : True if hint is a typing._AnnotatedAlias (e.g. typing.Annotated[int, 42] ). is_new_type def is_new_type ( hint : t . Any ) -> te . TypeGuard [ NewType ] [view_source] Returns : True if hint is a typing.NewType object. get_special_generic_aliases @functools . lru_cache () def get_special_generic_aliases () -> t . Dict [ str , SpecialGenericAlias ] [view_source] Returns a dictionary that contains all special generic aliases (like typing.List and typing.Mapping ) defined in the typing module. Example : import typing from typeapi.utils import get_special_generic_aliases mapping = get_special_generic_aliases () assert mapping [ 'List' ] is typing . List get_origins_to_special_generic_aliases @functools . lru_cache () def get_origins_to_special_generic_aliases ( ) -> t . Dict [ type , SpecialGenericAlias ] [view_source] Returns a dictionary that maps a native Python type to the typing special generic alias. Example : import typing from typeapi.utils import get_origins_to_special_generic_aliases mapping = get_origins_to_special_generic_aliases () assert mapping [ list ] is typing . List get_special_forms @functools . lru_cache () def get_special_forms () -> t . Dict [ str , SpecialGenericAlias ] [view_source] Returns a dictionary that contains all special forms (like typing.Final and typing.Union ) defined in the typing module. Example : import typing from typeapi.utils import get_special_forms mapping = get_special_forms () assert mapping [ 'Any' ] is typing . Any assert mapping [ 'Union' ] is typing . Union type_repr def type_repr ( obj ) [view_source] typing._type_repr() stolen from Python 3.8. get_type_hints def get_type_hints ( type_ : t . Any ) -> t . Dict [ str , t . Any ] [view_source] Like typing.get_type_hints() , but always includes extras. This is important when we want to inspect typing.Annotated hints (without extras the annotations are removed).","title":"typeapi.utils"},{"location":"api/typeapi.utils/#is_generic","text":"def is_generic ( hint : t . Any ) -> te . TypeGuard [ t . Type [ Generic ]] [view_source] Returns : True if hint is a subclass fo typing.Generic (and not an alias of it).","title":"is_generic"},{"location":"api/typeapi.utils/#is_generic_alias","text":"def is_generic_alias ( hint : t . Any ) -> te . TypeGuard [ GenericAlias ] [view_source] Returns : True if hint is a typing._GenericAlias or types.GenericAlias ( PEP 585 since Python 3.10+). !!! note In Python versions 3.8 and older, typing._GenericAlias is used also for special generic aliases (see is_special_generic_alias() ). This function will return False for these types of aliases to clearly distinct between special aliases and normal aliases, even if they share the same type.","title":"is_generic_alias"},{"location":"api/typeapi.utils/#is_union_type","text":"def is_union_type ( hint : t . Any ) -> te . TypeGuard [ UnionType ] [view_source] Returns : True if hint is a typing.Union or types.UnionType .","title":"is_union_type"},{"location":"api/typeapi.utils/#is_special_generic_alias","text":"def is_special_generic_alias ( hint : t . Any ) -> te . TypeGuard [ SpecialGenericAlias ] [view_source] Returns : True if hint is a typing._SpecialGenericAlias (like typing.List or typing.Mapping ). !!! note For Python versions 3.8 and older, the function treats typing._GenericAliases as special if their _special attribute is set to True . typing._SpecialGenericAlias was introduced in Python 3.9.","title":"is_special_generic_alias"},{"location":"api/typeapi.utils/#is_special_form","text":"def is_special_form ( hint : t . Any ) -> te . TypeGuard [ SpecialGenericAlias ] [view_source] Returns : True if hint is a typing._SpecialForm (like typing.Final or typing.Union ).","title":"is_special_form"},{"location":"api/typeapi.utils/#is_annotated_alias","text":"def is_annotated_alias ( hint : t . Any ) -> te . TypeGuard [ AnnotatedAlias ] [view_source] Returns : True if hint is a typing._AnnotatedAlias (e.g. typing.Annotated[int, 42] ).","title":"is_annotated_alias"},{"location":"api/typeapi.utils/#is_new_type","text":"def is_new_type ( hint : t . Any ) -> te . TypeGuard [ NewType ] [view_source] Returns : True if hint is a typing.NewType object.","title":"is_new_type"},{"location":"api/typeapi.utils/#get_special_generic_aliases","text":"@functools . lru_cache () def get_special_generic_aliases () -> t . Dict [ str , SpecialGenericAlias ] [view_source] Returns a dictionary that contains all special generic aliases (like typing.List and typing.Mapping ) defined in the typing module. Example : import typing from typeapi.utils import get_special_generic_aliases mapping = get_special_generic_aliases () assert mapping [ 'List' ] is typing . List","title":"get_special_generic_aliases"},{"location":"api/typeapi.utils/#get_origins_to_special_generic_aliases","text":"@functools . lru_cache () def get_origins_to_special_generic_aliases ( ) -> t . Dict [ type , SpecialGenericAlias ] [view_source] Returns a dictionary that maps a native Python type to the typing special generic alias. Example : import typing from typeapi.utils import get_origins_to_special_generic_aliases mapping = get_origins_to_special_generic_aliases () assert mapping [ list ] is typing . List","title":"get_origins_to_special_generic_aliases"},{"location":"api/typeapi.utils/#get_special_forms","text":"@functools . lru_cache () def get_special_forms () -> t . Dict [ str , SpecialGenericAlias ] [view_source] Returns a dictionary that contains all special forms (like typing.Final and typing.Union ) defined in the typing module. Example : import typing from typeapi.utils import get_special_forms mapping = get_special_forms () assert mapping [ 'Any' ] is typing . Any assert mapping [ 'Union' ] is typing . Union","title":"get_special_forms"},{"location":"api/typeapi.utils/#type_repr","text":"def type_repr ( obj ) [view_source] typing._type_repr() stolen from Python 3.8.","title":"type_repr"},{"location":"api/typeapi.utils/#get_type_hints","text":"def get_type_hints ( type_ : t . Any ) -> t . Dict [ str , t . Any ] [view_source] Like typing.get_type_hints() , but always includes extras. This is important when we want to inspect typing.Annotated hints (without extras the annotations are removed).","title":"get_type_hints"}]}