{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"typeapi","text":"<p>Compatibility: Python 3.6.3+</p> <p>The <code>typeapi</code> package provides an object-oriented interface for introspecting PEP484 type hints at runtime, including forward references that make use of the more recent PEP585 and PEP604 type hint features in Python versions that don't natively support them.</p> <p>The main API of this module is comprised of:</p> <ul> <li><code>typeapi.TypeHint()</code> \u2013 A class to parse low-level type hints and present them in a consistent, object-oriented API.</li> <li><code>typeapi.get_annotations()</code> \u2013 Retrieve an object's <code>__annotations__</code> with support for evaluating future type hints (PEP585, PEP604).</li> </ul> <p>The following kinds of type hints are currently supported:</p> Concrete type Description Added in <code>ClassTypeHint</code> For any normal or generic type as well as <code>typing.Any</code>. Provides access to the underlying type, the type arguments and parameters, if any. 1.0.0 <code>UnionTypeHint</code> Represents <code>Union</code> type hint and gives access to the union members. 1.0.0 <code>LiteralTypeHint</code> Represents a <code>Literal</code> type hint and gives access to the literal values. 1.0.0 <code>AnnotatedTypeHint</code> Represents an <code>Annotated</code> type hint and gives access to the annotated type as well as the metadata. 1.0.0 <code>TypeVarTypeHint</code> Represents a <code>TypeVar</code> type hint and gives an interface to access the variable's metadata (such as constarints, variance, ...). 1.0.0 <code>ForwardRefTypeHint</code> Represents a forward reference. Can be evaluated in Python 3.6+ even if it contains PEP585 and PEP604 expressions. 1.0.0, future support in 1.3.0 <code>TupleTypeHint</code> Reperesents a <code>Tuple</code> type hint, allowing you to differentiate between repeated and explicitly sized tuples. 1.2.0"},{"location":"#examples","title":"Examples","text":"<p>Inspect a <code>List[int]</code> type hint:</p> <pre><code># cat &lt;&lt;EOF | python -\nfrom typeapi import ClassTypeHint, TypeHint\nfrom typing import List\n\nhint = TypeHint(List[int])\nassert isinstance(hint, ClassTypeHint)\nassert hint.type is list\n\nitem_hint = hint[0]\nassert isinstance(item_hint, ClassTypeHint)\nassert item_hint.type is int\n</code></pre> <p>Retrieve the metadata from an <code>Annotated[...]</code> type hint:</p> <pre><code># cat &lt;&lt;EOF | python -\nfrom typeapi import AnnotatedTypeHint, ClassTypeHint, TypeHint\nfrom typing_extensions import Annotated\n\nhint = TypeHint(Annotated[int, 42])\nassert isinstance(hint, AnnotatedTypeHint)\nassert hint.type is int\nassert hint.metadata == (42,)\n\nsub_hint = hint[0]\nassert isinstance(sub_hint, ClassTypeHint)\nassert sub_hint.type is int\n</code></pre> <p>Parameterize one type hint with the parameterization of a generic alias:</p> <pre><code># cat &lt;&lt;EOF | python -\nfrom dataclasses import dataclass\nfrom typeapi import ClassTypeHint, TypeHint\nfrom typing import Generic, TypeVar\nfrom typing_extensions import Annotated\n\nT = TypeVar(\"T\")\n\n@dataclass\nclass MyGeneric(Generic[T]):\n  value: T\n\nhint = TypeHint(MyGeneric[int])\nassert isinstance(hint, ClassTypeHint)\nassert hint.get_parameter_map() == {T: int}\n\nmember_hint = TypeHint(T).parameterize(hint.get_parameter_map())\nassert isinstance(member_hint, ClassTypeHint)\nassert member_hint.type is int\n</code></pre> <p>Evaluate forward references with <code>get_annotations()</code>:</p> <pre><code># cat &lt;&lt;EOF | python -\nfrom typeapi import get_annotations\nfrom typing import Optional\nfrom sys import version_info\n\nclass MyType:\n  a: \"str | None\"\n\nannotations = get_annotations(MyType)\n\nif version_info[:2] &lt; (3, 10):\n  assert annotations == {\"a\": Optional[str]}\nelse:\n  assert annotations == {\"a\": str | None}\n</code></pre> <p>Evaluating forward references with the <code>TypeHint</code> API:</p> <pre><code># cat &lt;&lt;EOF | python -\nfrom typeapi import ClassTypeHint, ForwardRefTypeHint, TypeHint\n\nMyVector = \"list[MyType]\"\n\nclass MyType:\n  pass\n\nhint = TypeHint(MyVector).evaluate(globals())\nprint(hint)  # TypeHint(typing.List[__main__.MyType])\nassert isinstance(hint, ClassTypeHint)\nassert hint.type is list\n\nitem_hint = hint[0]\nassert isinstance(item_hint, ClassTypeHint)\nassert item_hint.type is MyType\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#140-2023-03-02","title":"1.4.0 (2023-03-02)","text":"TypeDescriptionPRIssuesAuthor Fix  provide experimental support for evaluating future type hints that perform a function call; sometimes this is used in the metadata for `Anntoated[...]` hints@NiklasRosenstein Fix  Support evaluation of future type hints in `typeapi.get_annotations()` and add new `typeapi.get_annotations(eval_str)` parameter. We backport a modified version of `inspect.get_annotations()` from Python 3.11 for this.@NiklasRosenstein"},{"location":"changelog/#135-2023-01-10","title":"1.3.5 (2023-01-10)","text":"TypeDescriptionPRIssuesAuthor Fix  fix type hint fake evaluation when an actual typing.Optional is encountered@NiklasRosenstein"},{"location":"changelog/#134-2022-12-10","title":"1.3.4 (2022-12-10)","text":"TypeDescriptionPRIssuesAuthor Fix  fix passing `TypeHint(source)` argument which before would not be accepted@NiklasRosenstein"},{"location":"changelog/#133-2022-12-05","title":"1.3.3 (2022-12-05)","text":"TypeDescriptionPRIssuesAuthor Feature  add `TypeHint.source`, `TypeHint.get_context()` and make `TypeHint.evaluate(context)` argument optional@NiklasRosenstein Fix  Support `types.UnionType` in Python 3.10+7@NiklasRosenstein"},{"location":"changelog/#132-2022-11-11","title":"1.3.2 (2022-11-11)","text":"TypeDescriptionPRIssuesAuthor Fix  fix evaluating type hints that are attributes of other objects (`FakeHint` did not implement `__getattr__()`)@NiklasRosenstein"},{"location":"changelog/#131-2022-11-11","title":"1.3.1 (2022-11-11)","text":"TypeDescriptionPRIssuesAuthor Fix  fix evaluation of PEP604 optional type hints (e.g. `int | None`)@NiklasRosenstein"},{"location":"changelog/#130-2022-11-11","title":"1.3.0 (2022-11-11)","text":"TypeDescriptionPRIssuesAuthor Feature  support future typing syntax (such as `list[int]` and `int | None`) when evaluating forward references.5@NiklasRosenstein"},{"location":"changelog/#121-2022-11-10","title":"1.2.1 (2022-11-10)","text":"TypeDescriptionPRIssuesAuthor Fix  expose TupleTypeHint@NiklasRosenstein"},{"location":"changelog/#120-2022-11-10","title":"1.2.0 (2022-11-10)","text":"TypeDescriptionPRIssuesAuthor Feature  add `TupleTypeHint` support@NiklasRosenstein"},{"location":"changelog/#110-2022-11-10","title":"1.1.0 (2022-11-10)","text":"TypeDescriptionPRIssuesAuthor Improvement  support all common special generic aliases instead of just List and Dict when using TypeHint.parameterize() or TypeHint.evaluate()@NiklasRosenstein Fix  Mark typeapi as requiring at least Python 3.6.3 or higher, this is because Forward references on class members are not correctly resolved by typing.get_type_hints() in 3.6.2 and before (see https://github.com/python/cpython/commit/1658ec07577ef9696cea76fcf7fac2da18403ec5#diff-ddb987fca5f5df0c9a2f5521ed687919d70bb3d64eaeb8021f98833a2a716887R1501-R1504)@NiklasRosenstein Improvement  Improve error message when `TypeHint._copy_with_args()` fails due to a TypeError (eg if the type is not actually subscriptable) to include the type in question.@NiklasRosenstein"},{"location":"changelog/#101-2022-11-06","title":"1.0.1 (2022-11-06)","text":"TypeDescriptionPRIssuesAuthor Fix  add `TypeHint.__iter__()`@NiklasRosenstein"},{"location":"changelog/#100-2022-11-06","title":"1.0.0 (2022-11-06)","text":"TypeDescriptionPRIssuesAuthor Breaking change  Full rewrite of `typeapi` with limited support for more exotic type hints but strong support for common runtime type hint needs.@NiklasRosenstein"},{"location":"changelog/#022-2022-08-30","title":"0.2.2 (2022-08-30)","text":"TypeDescriptionPRIssuesAuthor Fix  fix issue with `typeapi.get_annotations(include_bases=False)` if class has no explicit annotations3@NiklasRosenstein"},{"location":"changelog/#021-2022-06-20","title":"0.2.1 (2022-06-20)","text":"TypeDescriptionPRIssuesAuthor Improvement  Enable strict type checking in Mypy@NiklasRosenstein"},{"location":"changelog/#020-2022-05-29","title":"0.2.0 (2022-05-29)","text":"TypeDescriptionPRIssuesAuthor Improvement  Limit types accepted for `typeapi.get_annotations() to modules, types and callables as is also the case in `inspect.get_annotations()` starting with 3.10@NiklasRosenstein"},{"location":"changelog/#016-2022-04-19","title":"0.1.6 (2022-04-19)","text":"TypeDescriptionPRIssuesAuthor Feature  Add `recursive` argument to `ForwardRef.evaluate()`@NiklasRosenstein Feature  Add `ignore_name_errors` to `eval_types()`@NiklasRosenstein"},{"location":"changelog/#015-2022-03-23","title":"0.1.5 (2022-03-23)","text":"TypeDescriptionPRIssuesAuthor Feature  add `typeapi.utils.scope()`@NiklasRosenstein"},{"location":"changelog/#014-2022-03-23","title":"0.1.4 (2022-03-23)","text":"TypeDescriptionPRIssuesAuthor Feature  add `typeapi.utils.unwrap()`@NiklasRosenstein"},{"location":"changelog/#013-2022-03-23","title":"0.1.3 (2022-03-23)","text":"TypeDescriptionPRIssuesAuthor Feature  add `globalns` and `localns` parameters to `get_annotations()` and `ForwardRef.evaluate()`@NiklasRosenstein Feature  add `typeapi.utils.scoped()` decorator@NiklasRosenstein"},{"location":"changelog/#012-2022-03-22","title":"0.1.2 (2022-03-22)","text":"TypeDescriptionPRIssuesAuthor Improvement  add `get_annotations(include_bases)` parameter@NiklasRosenstein Improvement  update `ForweardRef.__repr__()`@NiklasRosenstein"},{"location":"changelog/#011-2022-03-17","title":"0.1.1 (2022-03-17)","text":"TypeDescriptionPRIssuesAuthor Fix  Fix an error caused when using `Type.get_orig_bases()` if the `Type.type` has non-generic bases@NiklasRosenstein Deprecation  Deprecated `get_type_hints()` in favor of new `get_annotations()`@NiklasRosenstein Fix  Fix `get_annotations()` in Python 3.9 and older to have the same behaviour as `inspect.get_annotations()` in that it does not include annotations of a classes' bases@NiklasRosenstein Feature  Add `typeapi.utils.is_typed_dict()` and the `typeapi.utils.TypedDict` protocol@NiklasRosenstein"},{"location":"changelog/#010-2022-03-17","title":"0.1.0 (2022-03-17)","text":"TypeDescriptionPRIssuesAuthor Feature  Add `Type.get_orig_bases()`@NiklasRosenstein Feature  Add `Type.get_orig_bases_parametrized()`@NiklasRosenstein Fix  Fix `infuse_type_parameters()` to replace sole `typeapi.TypeVar` instead of only occurrences in `typeapi.Type.args`@NiklasRosenstein Fix  Fix `infuse_type_parameters()` to replace sole `typeapi.TypeVar` instead of only occurrences in `typeapi.Type.args`@NiklasRosenstein Fix  Fix `Type.get_parameter_mapping()` return annotation@NiklasRosenstein Fix  Fix `infuse_type_parameters()` to handle plain `typeapi.TypeVar` and not just the like in `typeapi.Type.args`@NiklasRosenstein"},{"location":"changelog/#010a5-2022-03-17","title":"0.1.0a5 (2022-03-17)","text":"TypeDescriptionPRIssuesAuthor Breaking change  Change `ForwardRef` and `NewType` to hold the origin `typing` object@NiklasRosenstein Feature  Implement `ForwardRef.evaluate()`@NiklasRosenstein Feature  add `typeapi.eval_types()`@NiklasRosenstein Feature  add `typeapi.infuse_type_parameters()`@NiklasRosenstein"},{"location":"changelog/#010a4-2022-03-17","title":"0.1.0a4 (2022-03-17)","text":"TypeDescriptionPRIssuesAuthor Fix  fix `from typeapi import *`@NiklasRosenstein Improvement  export `get_type_hints()` and `type_repr()` in `typeapi` root module@NiklasRosenstein Improvement  `is_generic()` no longer returns true if the type is the actualy `typing.Generic` because only its subclasses of `__parameters__`@NiklasRosenstein Fix  `Type.of()` no longer errors on passing `typing.Generic` and handles it as `Type(typing.Generic, 0, None, None)`@NiklasRosenstein Feature  Add `Type.get_parameter_mapping()`@NiklasRosenstein Breaking change  Type hints are now converted recursively, all recursive API models now store `Hint` objects directly instead of the raw typing argument.@NiklasRosenstein"},{"location":"changelog/#010a3-2022-03-15","title":"0.1.0a3 (2022-03-15)","text":"TypeDescriptionPRIssuesAuthor Breaking change  remove `Type.args` field and instead make it a property@NiklasRosenstein Breaking change  Added `Type.info` property@NiklasRosenstein Feature  `deconstruct_type()` now supports concrete types@NiklasRosenstein Feature  export members from `typeapi.api`, `typeapi.parser` and `typeapi.deconstruct`, most notably `typeapi.of()` is not available as an alias for `typeapi.parser.parse_type_hint()`@NiklasRosenstein Breaking change  remove `Hint.source`@NiklasRosenstein Breaking change  remove `typeapi.deconstruct` module, make `typeapi.model.Type` have the fields that `TypeInfo` used to have and move `deconstruct_type()` to `Type.of()`@NiklasRosenstein"},{"location":"changelog/#010a2-2022-03-15","title":"0.1.0a2 (2022-03-15)","text":"TypeDescriptionPRIssuesAuthor Breaking change  add `Hint.source` field@NiklasRosenstein"},{"location":"api/typeapi.typehint/","title":"typeapi.typehint","text":""},{"location":"api/typeapi.typehint/#class-typehint","title":"Class TypeHint","text":"<pre><code>class TypeHint(object, metaclass=_TypeHintMeta)\n</code></pre> <p>[view_source]</p> <p>Base class that provides an object-oriented interface to a Python type hint.</p> <p></p> <p></p>"},{"location":"api/typeapi.typehint/#hint","title":"hint","text":"<pre><code>@property\ndef hint() -&gt; object\n</code></pre> <p>[view_source]</p> <p>The original type hint.</p> <p></p> <p></p>"},{"location":"api/typeapi.typehint/#origin","title":"origin","text":"<pre><code>@property\ndef origin() -&gt; \"object | None\"\n</code></pre> <p>[view_source]</p> <p>The original type behind a type hint (e.g. the <code>Generic.__origin__</code>). For example, for :class:<code>typing.List</code>, it is <code>list</code>. For :class:<code>typing.Sequence</code>, it is :class:<code>collections.abc.Sequence</code>.</p> <p></p> <p></p>"},{"location":"api/typeapi.typehint/#args","title":"args","text":"<pre><code>@property\ndef args() -&gt; Tuple[Any, ...]\n</code></pre> <p>[view_source]</p> <p>Type hint arguments are the values passed into type hint subscripts, e.g. in <code>Union[int, str]</code>, the arguments are <code>(int, str)</code>. We only return arguments that are expected to be types or other type hints. For example, <code>Literal[\"foo\", 0]</code> has an empty tuple for its <code>args</code>, and instead the values can be retrievd using :attr:<code>LiteralTypeHint.valuse</code>.</p> <p></p> <p></p>"},{"location":"api/typeapi.typehint/#parameters","title":"parameters","text":"<pre><code>@property\ndef parameters() -&gt; Tuple[Any, ...]\n</code></pre> <p>[view_source]</p> <p>The parameters of a type hint is basically :attr:<code>args</code> but filtered for <code>typing.TypeVar</code> objects.</p> <p></p> <p></p>"},{"location":"api/typeapi.typehint/#source","title":"source","text":"<pre><code>@property\ndef source() -&gt; \"Any | None\"\n</code></pre> <p>[view_source]</p> <p>The object from which on which the type hint was found, for example a class or a function.</p> <p></p> <p></p>"},{"location":"api/typeapi.typehint/#parameterize","title":"parameterize","text":"<pre><code>def parameterize(parameter_map: Mapping[object, Any]) -&gt; \"TypeHint\"\n</code></pre> <p>[view_source]</p> <p>Replace references to the type variables in the keys of parameter_map</p> <p>with the type hints of the associated values.</p> <p>Arguments:</p> <ul> <li><code>parameter_map</code>: A dictionary that maps :class:<code>TypeVar</code> to other type hints.</li> </ul> <p></p> <p></p>"},{"location":"api/typeapi.typehint/#evaluate","title":"evaluate","text":"<pre><code>def evaluate(context: \"HasGetitem[str, Any] | None\" = None) -&gt; \"TypeHint\"\n</code></pre> <p>[view_source]</p> <p>Evaluate forward references in the type hint using the given context.</p> <p>This method supports evaluating forward references that use PEP585 and PEP604 syntax even in older versions of Python that do not support the PEPs.</p> <p>Arguments:</p> <ul> <li><code>context</code>: An object that supports <code>__getitem__()</code> to retrieve a value by name. If this is not specified, the globals of the <code>__module__</code> of the type hint's source :attr:<code>source</code> is used instead. If no source exists, a :class:<code>RuntimeError</code> is raised.</li> </ul> <p></p> <p></p>"},{"location":"api/typeapi.typehint/#class-tupletypehint","title":"Class TupleTypeHint","text":"<pre><code>class TupleTypeHint(TypeHint)\n</code></pre> <p>[view_source]</p> <p></p> <p></p>"},{"location":"api/typeapi.typehint/#repeated","title":"repeated","text":"<pre><code>@property\ndef repeated() -&gt; bool\n</code></pre> <p>[view_source]</p> <p>Returns <code>True</code> if the Tuple is of arbitrary length, but only of one type.</p>"},{"location":"api/typeapi.utils/","title":"typeapi.utils","text":""},{"location":"api/typeapi.utils/#get_type_hint_origin_or_none","title":"get_type_hint_origin_or_none","text":"<pre><code>def get_type_hint_origin_or_none(hint: object) -&gt; \"Any | None\"\n</code></pre> <p>[view_source]</p> <p>Returns the origin type of a low-level type hint, or None.</p> <p></p> <p></p>"},{"location":"api/typeapi.utils/#get_type_hint_original_bases","title":"get_type_hint_original_bases","text":"<pre><code>def get_type_hint_original_bases(hint: object) -&gt; \"Tuple[Any, ...] | None\"\n</code></pre> <p>[view_source]</p> <p>Returns the original bases of a generic type.</p> <p></p> <p></p>"},{"location":"api/typeapi.utils/#get_type_hint_args","title":"get_type_hint_args","text":"<pre><code>def get_type_hint_args(hint: object) -&gt; Tuple[Any, ...]\n</code></pre> <p>[view_source]</p> <p>Returns the arguments of a low-level type hint. An empty tuple is returned if the hint is unparameterized.</p> <p></p> <p></p>"},{"location":"api/typeapi.utils/#get_type_hint_parameters","title":"get_type_hint_parameters","text":"<pre><code>def get_type_hint_parameters(hint: object) -&gt; Tuple[Any, ...]\n</code></pre> <p>[view_source]</p> <p>Returns the parameters of a type hint, i.e. the tuple of type variables.</p> <p></p> <p></p>"},{"location":"api/typeapi.utils/#get_type_var_from_string_repr","title":"get_type_var_from_string_repr","text":"<pre><code>def get_type_var_from_string_repr(type_var_repr: str) -&gt; object\n</code></pre> <p>[view_source]</p> <p>Returns a :class:<code>TypeVar</code> for its string rerpesentation.</p> <p></p> <p></p>"},{"location":"api/typeapi.utils/#get_subscriptable_type_hint_from_origin","title":"get_subscriptable_type_hint_from_origin","text":"<pre><code>def get_subscriptable_type_hint_from_origin(origin: object,\n                                            *,\n                                            __cache: Dict[Any,\n                                                          Any] = {}) -&gt; Any\n</code></pre> <p>[view_source]</p> <p>Given any type, returns its corresponding subscriptable version. This is the type itself in most cases (assuming it is a subclass of :class:<code>typing.Generic</code>), but for special types such as :class:<code>list</code> or :class:<code>collections.abc.Sequence</code>, it returns the respective special alias from the :mod:<code>typing</code> module instead.</p> <p></p> <p></p>"},{"location":"api/typeapi.utils/#type_repr","title":"type_repr","text":"<pre><code>def type_repr(obj: Any) -&gt; str\n</code></pre> <p>[view_source]</p> <p><code>typing._type_repr()</code> stolen from Python 3.8.</p> <p></p> <p></p>"},{"location":"api/typeapi.utils/#get_annotations","title":"get_annotations","text":"<pre><code>def get_annotations(obj: Union[Callable[..., Any], ModuleType, type],\n                    include_bases: bool = False,\n                    globalns: Optional[Dict[str, Any]] = None,\n                    localns: Optional[Dict[str, Any]] = None,\n                    eval_str: bool = True) -&gt; Dict[str, Any]\n</code></pre> <p>[view_source]</p> <p>Like <code>typing.get_type_hints()</code>, but always includes extras. This is important when we want to inspect <code>typing.Annotated</code> hints (without extras the annotations are removed). In Python 3.10 and onwards, this is an alias for <code>inspect.get_annotations()</code> with <code>eval_str=True</code>.</p> <p>If include_bases is set to <code>True</code>, annotations from base classes are taken into account as well.</p> <p>This function will take into account the locals and globals accessible through the frame associated with a function or type by the <code>scoped()</code> decorator.</p> <p></p> <p></p>"},{"location":"api/typeapi.utils/#class-typeddictprotocol","title":"Class TypedDictProtocol","text":"<pre><code>class TypedDictProtocol(Protocol)\n</code></pre> <p>[view_source]</p> <p>A protocol that describes <code>typing.TypedDict</code> values (which are actually instances of the <code>typing._TypedDictMeta</code> metaclass). Use is_typed_dict() to check if a hint is matches this protocol.</p> <p></p> <p></p>"},{"location":"api/typeapi.utils/#is_typed_dict","title":"is_typed_dict","text":"<pre><code>def is_typed_dict(hint: Any) -&gt; TypeGuard[TypedDictProtocol]\n</code></pre> <p>[view_source]</p> <p>Returns:</p> <p><code>True</code> if hint is a <code>typing.TypedDict</code>.</p> <p>!!! note</p> <p>Typed dictionaries are actually just type objects. This means <code>typeapi.of()</code> will represent them as   <code>typeapi.models.Type</code>.</p>"}]}