{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"typeapi Compatibility : Python 3.6.3+ The typeapi package provides an object-oriented interface for introspecting PEP484 type hints at runtime, including forward references that make use of the more recent PEP585 and PEP604 type hint features in Python versions that don't natively support them. The following kinds of type hints are currently supported: Concrete type Description Added in ClassTypeHint For any normal or generic type as well as typing.Any . Provides access to the underlying type, the type arguments and parameters, if any. 1.0.0 UnionTypeHint Represents Union type hint and gives access to the union members. 1.0.0 LiteralTypeHint Represents a Literal type hint and gives access to the literal values. 1.0.0 AnnotatedTypeHint Represents an Annotated type hint and gives access to the annotated type as well as the metadata. 1.0.0 TypeVarTypeHint Represents a TypeVar type hint and gives an interface to access the variable's metadata (such as constarints, variance, ...). 1.0.0 ForwardRefTypeHint Represents a forward reference. Can be evaluated in Python 3.6+ even if it contains PEP585 and PEP604 expressions. 1.0.0, future support in 1.3.0 TupleTypeHint Reperesents a Tuple type hint, allowing you to differentiate between repeated and explicitly sized tuples. 1.2.0 The main entry point to wrapping a low-level type hint is the TypeHint() constructor. Examples Inspect a List[int] type hint: # cat <<EOF | python - from typeapi import ClassTypeHint , TypeHint from typing import List hint = TypeHint ( List [ int ]) assert isinstance ( hint , ClassTypeHint ) assert hint . type is list item_hint = hint [ 0 ] assert isinstance ( item_hint , ClassTypeHint ) assert item_hint . type is int Retrieve the metadata from an Annotated[...] type hint: # cat <<EOF | python - from typeapi import AnnotatedTypeHint , ClassTypeHint , TypeHint from typing_extensions import Annotated hint = TypeHint ( Annotated [ int , 42 ]) assert isinstance ( hint , AnnotatedTypeHint ) assert hint . type is int assert hint . metadata == ( 42 ,) sub_hint = hint [ 0 ] assert isinstance ( sub_hint , ClassTypeHint ) assert sub_hint . type is int Parameterize one type hint with the parameterization of a generic alias: # cat <<EOF | python - from dataclasses import dataclass from typeapi import ClassTypeHint , TypeHint from typing import Generic , TypeVar from typing_extensions import Annotated T = TypeVar ( \"T\" ) @dataclass class MyGeneric ( Generic [ T ]): value : T hint = TypeHint ( MyGeneric [ int ]) assert isinstance ( hint , ClassTypeHint ) assert hint . get_parameter_map () == { T : int } member_hint = TypeHint ( T ) . parameterize ( hint . get_parameter_map ()) assert isinstance ( member_hint , ClassTypeHint ) assert member_hint . type is int Evaluate forward references: # cat <<EOF | python - from typeapi import ClassTypeHint , ForwardRefTypeHint , TypeHint MyVector = \"list[MyType]\" class MyType : pass hint = TypeHint ( MyVector ) . evaluate ( globals ()) print ( hint ) # TypeHint(typing.List[__main__.MyType]) assert isinstance ( hint , ClassTypeHint ) assert hint . type is list item_hint = hint [ 0 ] assert isinstance ( item_hint , ClassTypeHint ) assert item_hint . type is MyType","title":"Home"},{"location":"#typeapi","text":"Compatibility : Python 3.6.3+ The typeapi package provides an object-oriented interface for introspecting PEP484 type hints at runtime, including forward references that make use of the more recent PEP585 and PEP604 type hint features in Python versions that don't natively support them. The following kinds of type hints are currently supported: Concrete type Description Added in ClassTypeHint For any normal or generic type as well as typing.Any . Provides access to the underlying type, the type arguments and parameters, if any. 1.0.0 UnionTypeHint Represents Union type hint and gives access to the union members. 1.0.0 LiteralTypeHint Represents a Literal type hint and gives access to the literal values. 1.0.0 AnnotatedTypeHint Represents an Annotated type hint and gives access to the annotated type as well as the metadata. 1.0.0 TypeVarTypeHint Represents a TypeVar type hint and gives an interface to access the variable's metadata (such as constarints, variance, ...). 1.0.0 ForwardRefTypeHint Represents a forward reference. Can be evaluated in Python 3.6+ even if it contains PEP585 and PEP604 expressions. 1.0.0, future support in 1.3.0 TupleTypeHint Reperesents a Tuple type hint, allowing you to differentiate between repeated and explicitly sized tuples. 1.2.0 The main entry point to wrapping a low-level type hint is the TypeHint() constructor.","title":"typeapi"},{"location":"#examples","text":"Inspect a List[int] type hint: # cat <<EOF | python - from typeapi import ClassTypeHint , TypeHint from typing import List hint = TypeHint ( List [ int ]) assert isinstance ( hint , ClassTypeHint ) assert hint . type is list item_hint = hint [ 0 ] assert isinstance ( item_hint , ClassTypeHint ) assert item_hint . type is int Retrieve the metadata from an Annotated[...] type hint: # cat <<EOF | python - from typeapi import AnnotatedTypeHint , ClassTypeHint , TypeHint from typing_extensions import Annotated hint = TypeHint ( Annotated [ int , 42 ]) assert isinstance ( hint , AnnotatedTypeHint ) assert hint . type is int assert hint . metadata == ( 42 ,) sub_hint = hint [ 0 ] assert isinstance ( sub_hint , ClassTypeHint ) assert sub_hint . type is int Parameterize one type hint with the parameterization of a generic alias: # cat <<EOF | python - from dataclasses import dataclass from typeapi import ClassTypeHint , TypeHint from typing import Generic , TypeVar from typing_extensions import Annotated T = TypeVar ( \"T\" ) @dataclass class MyGeneric ( Generic [ T ]): value : T hint = TypeHint ( MyGeneric [ int ]) assert isinstance ( hint , ClassTypeHint ) assert hint . get_parameter_map () == { T : int } member_hint = TypeHint ( T ) . parameterize ( hint . get_parameter_map ()) assert isinstance ( member_hint , ClassTypeHint ) assert member_hint . type is int Evaluate forward references: # cat <<EOF | python - from typeapi import ClassTypeHint , ForwardRefTypeHint , TypeHint MyVector = \"list[MyType]\" class MyType : pass hint = TypeHint ( MyVector ) . evaluate ( globals ()) print ( hint ) # TypeHint(typing.List[__main__.MyType]) assert isinstance ( hint , ClassTypeHint ) assert hint . type is list item_hint = hint [ 0 ] assert isinstance ( item_hint , ClassTypeHint ) assert item_hint . type is MyType","title":"Examples"},{"location":"changelog/","text":"Unreleased Type Description PR Issues Author Feature add `TypeHint.source`, `TypeHint.get_context()` and make `TypeHint.evaluate(context)` argument optional @NiklasRosenstein Fix Support `types.UnionType` in Python 3.10+ 7 @NiklasRosenstein 1.3.2 (2022-11-11) Type Description PR Issues Author Fix fix evaluating type hints that are attributes of other objects (`FakeHint` did not implement `__getattr__()`) @NiklasRosenstein 1.3.1 (2022-11-11) Type Description PR Issues Author Fix fix evaluation of PEP604 optional type hints (e.g. `int | None`) @NiklasRosenstein 1.3.0 (2022-11-11) Type Description PR Issues Author Feature support future typing syntax (such as `list[int]` and `int | None`) when evaluating forward references. 5 @NiklasRosenstein 1.2.1 (2022-11-10) Type Description PR Issues Author Fix expose TupleTypeHint @NiklasRosenstein 1.2.0 (2022-11-10) Type Description PR Issues Author Feature add `TupleTypeHint` support @NiklasRosenstein 1.1.0 (2022-11-10) Type Description PR Issues Author Improvement support all common special generic aliases instead of just List and Dict when using TypeHint.parameterize() or TypeHint.evaluate() @NiklasRosenstein Fix Mark typeapi as requiring at least Python 3.6.3 or higher, this is because Forward references on class members are not correctly resolved by typing.get_type_hints() in 3.6.2 and before (see https://github.com/python/cpython/commit/1658ec07577ef9696cea76fcf7fac2da18403ec5#diff-ddb987fca5f5df0c9a2f5521ed687919d70bb3d64eaeb8021f98833a2a716887R1501-R1504) @NiklasRosenstein Improvement Improve error message when `TypeHint._copy_with_args()` fails due to a TypeError (eg if the type is not actually subscriptable) to include the type in question. @NiklasRosenstein 1.0.1 (2022-11-06) Type Description PR Issues Author Fix add `TypeHint.__iter__()` @NiklasRosenstein 1.0.0 (2022-11-06) Type Description PR Issues Author Breaking change Full rewrite of `typeapi` with limited support for more exotic type hints but strong support for common runtime type hint needs. @NiklasRosenstein 0.2.2 (2022-08-30) Type Description PR Issues Author Fix fix issue with `typeapi.get_annotations(include_bases=False)` if class has no explicit annotations 3 @NiklasRosenstein 0.2.1 (2022-06-20) Type Description PR Issues Author Improvement Enable strict type checking in Mypy @NiklasRosenstein 0.2.0 (2022-05-29) Type Description PR Issues Author Improvement Limit types accepted for `typeapi.get_annotations() to modules, types and callables as is also the case in `inspect.get_annotations()` starting with 3.10 @NiklasRosenstein 0.1.6 (2022-04-19) Type Description PR Issues Author Feature Add `recursive` argument to `ForwardRef.evaluate()` @NiklasRosenstein Feature Add `ignore_name_errors` to `eval_types()` @NiklasRosenstein 0.1.5 (2022-03-23) Type Description PR Issues Author Feature add `typeapi.utils.scope()` @NiklasRosenstein 0.1.4 (2022-03-23) Type Description PR Issues Author Feature add `typeapi.utils.unwrap()` @NiklasRosenstein 0.1.3 (2022-03-23) Type Description PR Issues Author Feature add `globalns` and `localns` parameters to `get_annotations()` and `ForwardRef.evaluate()` @NiklasRosenstein Feature add `typeapi.utils.scoped()` decorator @NiklasRosenstein 0.1.2 (2022-03-22) Type Description PR Issues Author Improvement add `get_annotations(include_bases)` parameter @NiklasRosenstein Improvement update `ForweardRef.__repr__()` @NiklasRosenstein 0.1.1 (2022-03-17) Type Description PR Issues Author Fix Fix an error caused when using `Type.get_orig_bases()` if the `Type.type` has non-generic bases @NiklasRosenstein Deprecation Deprecated `get_type_hints()` in favor of new `get_annotations()` @NiklasRosenstein Fix Fix `get_annotations()` in Python 3.9 and older to have the same behaviour as `inspect.get_annotations()` in that it does not include annotations of a classes' bases @NiklasRosenstein Feature Add `typeapi.utils.is_typed_dict()` and the `typeapi.utils.TypedDict` protocol @NiklasRosenstein 0.1.0 (2022-03-17) Type Description PR Issues Author Feature Add `Type.get_orig_bases()` @NiklasRosenstein Feature Add `Type.get_orig_bases_parametrized()` @NiklasRosenstein Fix Fix `infuse_type_parameters()` to replace sole `typeapi.TypeVar` instead of only occurrences in `typeapi.Type.args` @NiklasRosenstein Fix Fix `infuse_type_parameters()` to replace sole `typeapi.TypeVar` instead of only occurrences in `typeapi.Type.args` @NiklasRosenstein Fix Fix `Type.get_parameter_mapping()` return annotation @NiklasRosenstein Fix Fix `infuse_type_parameters()` to handle plain `typeapi.TypeVar` and not just the like in `typeapi.Type.args` @NiklasRosenstein 0.1.0a5 (2022-03-17) Type Description PR Issues Author Breaking change Change `ForwardRef` and `NewType` to hold the origin `typing` object @NiklasRosenstein Feature Implement `ForwardRef.evaluate()` @NiklasRosenstein Feature add `typeapi.eval_types()` @NiklasRosenstein Feature add `typeapi.infuse_type_parameters()` @NiklasRosenstein 0.1.0a4 (2022-03-17) Type Description PR Issues Author Fix fix `from typeapi import *` @NiklasRosenstein Improvement export `get_type_hints()` and `type_repr()` in `typeapi` root module @NiklasRosenstein Improvement `is_generic()` no longer returns true if the type is the actualy `typing.Generic` because only its subclasses of `__parameters__` @NiklasRosenstein Fix `Type.of()` no longer errors on passing `typing.Generic` and handles it as `Type(typing.Generic, 0, None, None)` @NiklasRosenstein Feature Add `Type.get_parameter_mapping()` @NiklasRosenstein Breaking change Type hints are now converted recursively, all recursive API models now store `Hint` objects directly instead of the raw typing argument. @NiklasRosenstein 0.1.0a3 (2022-03-15) Type Description PR Issues Author Breaking change remove `Type.args` field and instead make it a property @NiklasRosenstein Breaking change Added `Type.info` property @NiklasRosenstein Feature `deconstruct_type()` now supports concrete types @NiklasRosenstein Feature export members from `typeapi.api`, `typeapi.parser` and `typeapi.deconstruct`, most notably `typeapi.of()` is not available as an alias for `typeapi.parser.parse_type_hint()` @NiklasRosenstein Breaking change remove `Hint.source` @NiklasRosenstein Breaking change remove `typeapi.deconstruct` module, make `typeapi.model.Type` have the fields that `TypeInfo` used to have and move `deconstruct_type()` to `Type.of()` @NiklasRosenstein 0.1.0a2 (2022-03-15) Type Description PR Issues Author Breaking change add `Hint.source` field @NiklasRosenstein","title":"Changelog"},{"location":"changelog/#unreleased","text":"Type Description PR Issues Author Feature add `TypeHint.source`, `TypeHint.get_context()` and make `TypeHint.evaluate(context)` argument optional @NiklasRosenstein Fix Support `types.UnionType` in Python 3.10+ 7 @NiklasRosenstein","title":"Unreleased"},{"location":"changelog/#132-2022-11-11","text":"Type Description PR Issues Author Fix fix evaluating type hints that are attributes of other objects (`FakeHint` did not implement `__getattr__()`) @NiklasRosenstein","title":"1.3.2 (2022-11-11)"},{"location":"changelog/#131-2022-11-11","text":"Type Description PR Issues Author Fix fix evaluation of PEP604 optional type hints (e.g. `int | None`) @NiklasRosenstein","title":"1.3.1 (2022-11-11)"},{"location":"changelog/#130-2022-11-11","text":"Type Description PR Issues Author Feature support future typing syntax (such as `list[int]` and `int | None`) when evaluating forward references. 5 @NiklasRosenstein","title":"1.3.0 (2022-11-11)"},{"location":"changelog/#121-2022-11-10","text":"Type Description PR Issues Author Fix expose TupleTypeHint @NiklasRosenstein","title":"1.2.1 (2022-11-10)"},{"location":"changelog/#120-2022-11-10","text":"Type Description PR Issues Author Feature add `TupleTypeHint` support @NiklasRosenstein","title":"1.2.0 (2022-11-10)"},{"location":"changelog/#110-2022-11-10","text":"Type Description PR Issues Author Improvement support all common special generic aliases instead of just List and Dict when using TypeHint.parameterize() or TypeHint.evaluate() @NiklasRosenstein Fix Mark typeapi as requiring at least Python 3.6.3 or higher, this is because Forward references on class members are not correctly resolved by typing.get_type_hints() in 3.6.2 and before (see https://github.com/python/cpython/commit/1658ec07577ef9696cea76fcf7fac2da18403ec5#diff-ddb987fca5f5df0c9a2f5521ed687919d70bb3d64eaeb8021f98833a2a716887R1501-R1504) @NiklasRosenstein Improvement Improve error message when `TypeHint._copy_with_args()` fails due to a TypeError (eg if the type is not actually subscriptable) to include the type in question. @NiklasRosenstein","title":"1.1.0 (2022-11-10)"},{"location":"changelog/#101-2022-11-06","text":"Type Description PR Issues Author Fix add `TypeHint.__iter__()` @NiklasRosenstein","title":"1.0.1 (2022-11-06)"},{"location":"changelog/#100-2022-11-06","text":"Type Description PR Issues Author Breaking change Full rewrite of `typeapi` with limited support for more exotic type hints but strong support for common runtime type hint needs. @NiklasRosenstein","title":"1.0.0 (2022-11-06)"},{"location":"changelog/#022-2022-08-30","text":"Type Description PR Issues Author Fix fix issue with `typeapi.get_annotations(include_bases=False)` if class has no explicit annotations 3 @NiklasRosenstein","title":"0.2.2 (2022-08-30)"},{"location":"changelog/#021-2022-06-20","text":"Type Description PR Issues Author Improvement Enable strict type checking in Mypy @NiklasRosenstein","title":"0.2.1 (2022-06-20)"},{"location":"changelog/#020-2022-05-29","text":"Type Description PR Issues Author Improvement Limit types accepted for `typeapi.get_annotations() to modules, types and callables as is also the case in `inspect.get_annotations()` starting with 3.10 @NiklasRosenstein","title":"0.2.0 (2022-05-29)"},{"location":"changelog/#016-2022-04-19","text":"Type Description PR Issues Author Feature Add `recursive` argument to `ForwardRef.evaluate()` @NiklasRosenstein Feature Add `ignore_name_errors` to `eval_types()` @NiklasRosenstein","title":"0.1.6 (2022-04-19)"},{"location":"changelog/#015-2022-03-23","text":"Type Description PR Issues Author Feature add `typeapi.utils.scope()` @NiklasRosenstein","title":"0.1.5 (2022-03-23)"},{"location":"changelog/#014-2022-03-23","text":"Type Description PR Issues Author Feature add `typeapi.utils.unwrap()` @NiklasRosenstein","title":"0.1.4 (2022-03-23)"},{"location":"changelog/#013-2022-03-23","text":"Type Description PR Issues Author Feature add `globalns` and `localns` parameters to `get_annotations()` and `ForwardRef.evaluate()` @NiklasRosenstein Feature add `typeapi.utils.scoped()` decorator @NiklasRosenstein","title":"0.1.3 (2022-03-23)"},{"location":"changelog/#012-2022-03-22","text":"Type Description PR Issues Author Improvement add `get_annotations(include_bases)` parameter @NiklasRosenstein Improvement update `ForweardRef.__repr__()` @NiklasRosenstein","title":"0.1.2 (2022-03-22)"},{"location":"changelog/#011-2022-03-17","text":"Type Description PR Issues Author Fix Fix an error caused when using `Type.get_orig_bases()` if the `Type.type` has non-generic bases @NiklasRosenstein Deprecation Deprecated `get_type_hints()` in favor of new `get_annotations()` @NiklasRosenstein Fix Fix `get_annotations()` in Python 3.9 and older to have the same behaviour as `inspect.get_annotations()` in that it does not include annotations of a classes' bases @NiklasRosenstein Feature Add `typeapi.utils.is_typed_dict()` and the `typeapi.utils.TypedDict` protocol @NiklasRosenstein","title":"0.1.1 (2022-03-17)"},{"location":"changelog/#010-2022-03-17","text":"Type Description PR Issues Author Feature Add `Type.get_orig_bases()` @NiklasRosenstein Feature Add `Type.get_orig_bases_parametrized()` @NiklasRosenstein Fix Fix `infuse_type_parameters()` to replace sole `typeapi.TypeVar` instead of only occurrences in `typeapi.Type.args` @NiklasRosenstein Fix Fix `infuse_type_parameters()` to replace sole `typeapi.TypeVar` instead of only occurrences in `typeapi.Type.args` @NiklasRosenstein Fix Fix `Type.get_parameter_mapping()` return annotation @NiklasRosenstein Fix Fix `infuse_type_parameters()` to handle plain `typeapi.TypeVar` and not just the like in `typeapi.Type.args` @NiklasRosenstein","title":"0.1.0 (2022-03-17)"},{"location":"changelog/#010a5-2022-03-17","text":"Type Description PR Issues Author Breaking change Change `ForwardRef` and `NewType` to hold the origin `typing` object @NiklasRosenstein Feature Implement `ForwardRef.evaluate()` @NiklasRosenstein Feature add `typeapi.eval_types()` @NiklasRosenstein Feature add `typeapi.infuse_type_parameters()` @NiklasRosenstein","title":"0.1.0a5 (2022-03-17)"},{"location":"changelog/#010a4-2022-03-17","text":"Type Description PR Issues Author Fix fix `from typeapi import *` @NiklasRosenstein Improvement export `get_type_hints()` and `type_repr()` in `typeapi` root module @NiklasRosenstein Improvement `is_generic()` no longer returns true if the type is the actualy `typing.Generic` because only its subclasses of `__parameters__` @NiklasRosenstein Fix `Type.of()` no longer errors on passing `typing.Generic` and handles it as `Type(typing.Generic, 0, None, None)` @NiklasRosenstein Feature Add `Type.get_parameter_mapping()` @NiklasRosenstein Breaking change Type hints are now converted recursively, all recursive API models now store `Hint` objects directly instead of the raw typing argument. @NiklasRosenstein","title":"0.1.0a4 (2022-03-17)"},{"location":"changelog/#010a3-2022-03-15","text":"Type Description PR Issues Author Breaking change remove `Type.args` field and instead make it a property @NiklasRosenstein Breaking change Added `Type.info` property @NiklasRosenstein Feature `deconstruct_type()` now supports concrete types @NiklasRosenstein Feature export members from `typeapi.api`, `typeapi.parser` and `typeapi.deconstruct`, most notably `typeapi.of()` is not available as an alias for `typeapi.parser.parse_type_hint()` @NiklasRosenstein Breaking change remove `Hint.source` @NiklasRosenstein Breaking change remove `typeapi.deconstruct` module, make `typeapi.model.Type` have the fields that `TypeInfo` used to have and move `deconstruct_type()` to `Type.of()` @NiklasRosenstein","title":"0.1.0a3 (2022-03-15)"},{"location":"changelog/#010a2-2022-03-15","text":"Type Description PR Issues Author Breaking change add `Hint.source` field @NiklasRosenstein","title":"0.1.0a2 (2022-03-15)"},{"location":"api/typeapi/","text":"","title":"typeapi"},{"location":"api/typeapi.typehint/","text":"Class TypeHint class TypeHint ( object , metaclass = _TypeHintMeta ) [view_source] Base class that provides an object-oriented interface to a Python type hint. hint @property def hint () -> object [view_source] The original type hint. origin @property def origin () -> \"object | None\" [view_source] The original type behind a type hint (e.g. the Generic.__origin__ ). For example, for :class: typing.List , it is list . For :class: typing.Sequence , it is :class: collections.abc.Sequence . args @property def args () -> Tuple [ Any , ... ] [view_source] Type hint arguments are the values passed into type hint subscripts, e.g. in Union[int, str] , the arguments are (int, str) . We only return arguments that are expected to be types or other type hints. For example, Literal[\"foo\", 0] has an empty tuple for its args , and instead the values can be retrievd using :attr: LiteralTypeHint.valuse . parameters @property def parameters () -> Tuple [ Any , ... ] [view_source] The parameters of a type hint is basically :attr: args but filtered for typing.TypeVar objects. source @property def source () -> \"Any | None\" [view_source] The object from which on which the type hint was found, for example a class or a function. parameterize def parameterize ( parameter_map : Mapping [ object , Any ]) -> \"TypeHint\" [view_source] Replace references to the type variables in the keys of parameter_map with the type hints of the associated values. Arguments : parameter_map : A dictionary that maps :class: TypeVar to other type hints. evaluate def evaluate ( context : \"HasGetitem[str, Any] | None\" = None ) -> \"TypeHint\" [view_source] Evaluate forward references in the type hint using the given context . This method supports evaluating forward references that use PEP585 and PEP604 syntax even in older versions of Python that do not support the PEPs. Arguments : context : An object that supports __getitem__() to retrieve a value by name. If this is not specified, the globals of the __module__ of the type hint's source :attr: source is used instead. If no source exists, a :class: RuntimeError is raised. Class TupleTypeHint class TupleTypeHint ( TypeHint ) [view_source] repeated @property def repeated () -> bool [view_source] Returns True if the Tuple is of arbitrary length, but only of one type.","title":"typeapi.typehint"},{"location":"api/typeapi.typehint/#class-typehint","text":"class TypeHint ( object , metaclass = _TypeHintMeta ) [view_source] Base class that provides an object-oriented interface to a Python type hint.","title":"Class TypeHint"},{"location":"api/typeapi.typehint/#hint","text":"@property def hint () -> object [view_source] The original type hint.","title":"hint"},{"location":"api/typeapi.typehint/#origin","text":"@property def origin () -> \"object | None\" [view_source] The original type behind a type hint (e.g. the Generic.__origin__ ). For example, for :class: typing.List , it is list . For :class: typing.Sequence , it is :class: collections.abc.Sequence .","title":"origin"},{"location":"api/typeapi.typehint/#args","text":"@property def args () -> Tuple [ Any , ... ] [view_source] Type hint arguments are the values passed into type hint subscripts, e.g. in Union[int, str] , the arguments are (int, str) . We only return arguments that are expected to be types or other type hints. For example, Literal[\"foo\", 0] has an empty tuple for its args , and instead the values can be retrievd using :attr: LiteralTypeHint.valuse .","title":"args"},{"location":"api/typeapi.typehint/#parameters","text":"@property def parameters () -> Tuple [ Any , ... ] [view_source] The parameters of a type hint is basically :attr: args but filtered for typing.TypeVar objects.","title":"parameters"},{"location":"api/typeapi.typehint/#source","text":"@property def source () -> \"Any | None\" [view_source] The object from which on which the type hint was found, for example a class or a function.","title":"source"},{"location":"api/typeapi.typehint/#parameterize","text":"def parameterize ( parameter_map : Mapping [ object , Any ]) -> \"TypeHint\" [view_source] Replace references to the type variables in the keys of parameter_map with the type hints of the associated values. Arguments : parameter_map : A dictionary that maps :class: TypeVar to other type hints.","title":"parameterize"},{"location":"api/typeapi.typehint/#evaluate","text":"def evaluate ( context : \"HasGetitem[str, Any] | None\" = None ) -> \"TypeHint\" [view_source] Evaluate forward references in the type hint using the given context . This method supports evaluating forward references that use PEP585 and PEP604 syntax even in older versions of Python that do not support the PEPs. Arguments : context : An object that supports __getitem__() to retrieve a value by name. If this is not specified, the globals of the __module__ of the type hint's source :attr: source is used instead. If no source exists, a :class: RuntimeError is raised.","title":"evaluate"},{"location":"api/typeapi.typehint/#class-tupletypehint","text":"class TupleTypeHint ( TypeHint ) [view_source]","title":"Class TupleTypeHint"},{"location":"api/typeapi.typehint/#repeated","text":"@property def repeated () -> bool [view_source] Returns True if the Tuple is of arbitrary length, but only of one type.","title":"repeated"},{"location":"api/typeapi.utils/","text":"get_type_hint_origin_or_none def get_type_hint_origin_or_none ( hint : object ) -> \"Any | None\" [view_source] Returns the origin type of a low-level type hint, or None. get_type_hint_original_bases def get_type_hint_original_bases ( hint : object ) -> \"Tuple[Any, ...] | None\" [view_source] Returns the original bases of a generic type. get_type_hint_args def get_type_hint_args ( hint : object ) -> Tuple [ Any , ... ] [view_source] Returns the arguments of a low-level type hint. An empty tuple is returned if the hint is unparameterized. get_type_hint_parameters def get_type_hint_parameters ( hint : object ) -> Tuple [ Any , ... ] [view_source] Returns the parameters of a type hint, i.e. the tuple of type variables. get_type_var_from_string_repr def get_type_var_from_string_repr ( type_var_repr : str ) -> object [view_source] Returns a :class: TypeVar for its string rerpesentation. get_subscriptable_type_hint_from_origin def get_subscriptable_type_hint_from_origin ( origin : object , * , __cache : Dict [ Any , Any ] = {}) -> Any [view_source] Given any type, returns its corresponding subscriptable version. This is the type itself in most cases (assuming it is a subclass of :class: typing.Generic ), but for special types such as :class: list or :class: collections.abc.Sequence , it returns the respective special alias from the :mod: typing module instead. type_repr def type_repr ( obj : Any ) -> str [view_source] typing._type_repr() stolen from Python 3.8. get_annotations def get_annotations ( obj : Union [ Callable [ ... , Any ], ModuleType , type ], include_bases : bool = False , globalns : Optional [ Dict [ str , Any ]] = None , localns : Optional [ Dict [ str , Any ]] = None ) -> Dict [ str , Any ] [view_source] Like typing.get_type_hints() , but always includes extras. This is important when we want to inspect typing.Annotated hints (without extras the annotations are removed). In Python 3.10 and onwards, this is an alias for inspect.get_annotations() with eval_str=True . If include_bases is set to True , annotations from base classes are taken into account as well. This function will take into account the locals and globals accessible through the frame associated with a function or type by the scoped() decorator. Class TypedDictProtocol class TypedDictProtocol ( Protocol ) [view_source] A protocol that describes typing.TypedDict values (which are actually instances of the typing._TypedDictMeta metaclass). Use is_typed_dict() to check if a hint is matches this protocol. is_typed_dict def is_typed_dict ( hint : Any ) -> TypeGuard [ TypedDictProtocol ] [view_source] Returns : True if hint is a typing.TypedDict . !!! note Typed dictionaries are actually just type objects. This means typeapi.of() will represent them as typeapi.models.Type .","title":"typeapi.utils"},{"location":"api/typeapi.utils/#get_type_hint_origin_or_none","text":"def get_type_hint_origin_or_none ( hint : object ) -> \"Any | None\" [view_source] Returns the origin type of a low-level type hint, or None.","title":"get_type_hint_origin_or_none"},{"location":"api/typeapi.utils/#get_type_hint_original_bases","text":"def get_type_hint_original_bases ( hint : object ) -> \"Tuple[Any, ...] | None\" [view_source] Returns the original bases of a generic type.","title":"get_type_hint_original_bases"},{"location":"api/typeapi.utils/#get_type_hint_args","text":"def get_type_hint_args ( hint : object ) -> Tuple [ Any , ... ] [view_source] Returns the arguments of a low-level type hint. An empty tuple is returned if the hint is unparameterized.","title":"get_type_hint_args"},{"location":"api/typeapi.utils/#get_type_hint_parameters","text":"def get_type_hint_parameters ( hint : object ) -> Tuple [ Any , ... ] [view_source] Returns the parameters of a type hint, i.e. the tuple of type variables.","title":"get_type_hint_parameters"},{"location":"api/typeapi.utils/#get_type_var_from_string_repr","text":"def get_type_var_from_string_repr ( type_var_repr : str ) -> object [view_source] Returns a :class: TypeVar for its string rerpesentation.","title":"get_type_var_from_string_repr"},{"location":"api/typeapi.utils/#get_subscriptable_type_hint_from_origin","text":"def get_subscriptable_type_hint_from_origin ( origin : object , * , __cache : Dict [ Any , Any ] = {}) -> Any [view_source] Given any type, returns its corresponding subscriptable version. This is the type itself in most cases (assuming it is a subclass of :class: typing.Generic ), but for special types such as :class: list or :class: collections.abc.Sequence , it returns the respective special alias from the :mod: typing module instead.","title":"get_subscriptable_type_hint_from_origin"},{"location":"api/typeapi.utils/#type_repr","text":"def type_repr ( obj : Any ) -> str [view_source] typing._type_repr() stolen from Python 3.8.","title":"type_repr"},{"location":"api/typeapi.utils/#get_annotations","text":"def get_annotations ( obj : Union [ Callable [ ... , Any ], ModuleType , type ], include_bases : bool = False , globalns : Optional [ Dict [ str , Any ]] = None , localns : Optional [ Dict [ str , Any ]] = None ) -> Dict [ str , Any ] [view_source] Like typing.get_type_hints() , but always includes extras. This is important when we want to inspect typing.Annotated hints (without extras the annotations are removed). In Python 3.10 and onwards, this is an alias for inspect.get_annotations() with eval_str=True . If include_bases is set to True , annotations from base classes are taken into account as well. This function will take into account the locals and globals accessible through the frame associated with a function or type by the scoped() decorator.","title":"get_annotations"},{"location":"api/typeapi.utils/#class-typeddictprotocol","text":"class TypedDictProtocol ( Protocol ) [view_source] A protocol that describes typing.TypedDict values (which are actually instances of the typing._TypedDictMeta metaclass). Use is_typed_dict() to check if a hint is matches this protocol.","title":"Class TypedDictProtocol"},{"location":"api/typeapi.utils/#is_typed_dict","text":"def is_typed_dict ( hint : Any ) -> TypeGuard [ TypedDictProtocol ] [view_source] Returns : True if hint is a typing.TypedDict . !!! note Typed dictionaries are actually just type objects. This means typeapi.of() will represent them as typeapi.models.Type .","title":"is_typed_dict"}]}