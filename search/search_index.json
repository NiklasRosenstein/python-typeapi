{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"typeapi Typeapi provides a sane and stable API to introspect Python type hints. Installation $ pip install typeapi Quickstart import typing from typeapi import parse_type_hint print ( parse_type_hint ( typing . Any )) # Type(object) print ( parse_type_hint ( typing . List )) # Type(list) print ( parse_type_hint ( typing . Mapping [ str , int ])) # Type(collections.abc.Mapping, (Type(str), Type(int))) print ( parse_type_hint ( typing . Union [ str , int ])) # Union(int, str) print ( parse_type_hint ( str | int )) # Union(int, str) print ( parse_type_hint ( str | int | None )) # Optional(Union[int, str]) print ( parse_type_hint ( typing . Annotated [ int , 42 ])) # Annotated(int, 42) print ( parse_type_hint ( typing . Annotated [ int , 42 ])) # Annotated(int, 42) print ( parse_type_hint ( 'str' , __name__ )) # Type(str)","title":"Home"},{"location":"#typeapi","text":"Typeapi provides a sane and stable API to introspect Python type hints.","title":"typeapi"},{"location":"#installation","text":"$ pip install typeapi","title":"Installation"},{"location":"#quickstart","text":"import typing from typeapi import parse_type_hint print ( parse_type_hint ( typing . Any )) # Type(object) print ( parse_type_hint ( typing . List )) # Type(list) print ( parse_type_hint ( typing . Mapping [ str , int ])) # Type(collections.abc.Mapping, (Type(str), Type(int))) print ( parse_type_hint ( typing . Union [ str , int ])) # Union(int, str) print ( parse_type_hint ( str | int )) # Union(int, str) print ( parse_type_hint ( str | int | None )) # Optional(Union[int, str]) print ( parse_type_hint ( typing . Annotated [ int , 42 ])) # Annotated(int, 42) print ( parse_type_hint ( typing . Annotated [ int , 42 ])) # Annotated(int, 42) print ( parse_type_hint ( 'str' , __name__ )) # Type(str)","title":"Quickstart"},{"location":"api/typeapi.deconstruct/","text":"Deconstruct concrete types and aliases. Class TypeInfo class TypeInfo ( t . NamedTuple ) [view_source] Contains information about a type hint that is either a fixed type or an alias (i.e. a parametrized type). origin The original Python type underlying the type hint. nparams The number of type parameters that the origin type accepts. parameters The type variables from the origin type's original definition. Note that this may be None even if nparams is greater than zero. This is usually the case for special generic aliases like typing.List for which no explicit type variables are defined in the typing module. args The type arguments that the origin was parametrized with. This is None if the type is not explicitly parametrized. It may still contain typing.TypeVars if that is what the type was parametrized with. with_args def with_args ( args : t . Tuple [ TypeArg , ... ]) -> TypeInfo [view_source] Return a copy of the TypeInfo object, but args replaced by the args parameter value. deconstruct_type def deconstruct_type ( type_ : t . Any ) -> TypeInfo [view_source] Deconstruct a type hint that is not a typing \"special form\" or another type of exotic hint, i.e. a hint that an actual singular type, and return its TypeInfo . Arguments : type_ any - The type hint to deconstruct. Raises : ValueError - If the type_ parameter cannot be deconstructed into a TypeInfo . For example, passing a typing.Annotated object or typing.ClassVar will cause this error to be raised. Example : import collections.abc import typing from typeapi.deconstruct import deconstruct_type , TypeInfo T = typing . TypeVar ( 'T' ) assert deconstruct_type ( typing . Any ) == TypeInfo ( object , 0 , None , None ) assert deconstruct_type ( typing . List ) == TypeInfo ( list , 1 , None , None ) assert deconstruct_type ( t . Mapping [ str , int ]) == TypeInfo ( collections . abc . Mapping , 2 , None , ( str , int ,)) class MyGeneric ( t . Generic [ T ]): pass assert deconstruct_type ( MyGeneric ) == TypeInfo ( MyGeneric , 1 , ( T ,), None ) assert deconstruct_type ( MyGeneric [ int ]) == TypeInfo ( MyGeneric , 1 , ( T ,), ( int ,)) assert deconstruct_type ( MyGeneric [ T ]) == TypeInfo ( MyGeneric , 1 , ( T ,), ( T ,))","title":"typeapi.deconstruct"},{"location":"api/typeapi.deconstruct/#class-typeinfo","text":"class TypeInfo ( t . NamedTuple ) [view_source] Contains information about a type hint that is either a fixed type or an alias (i.e. a parametrized type).","title":"Class TypeInfo"},{"location":"api/typeapi.deconstruct/#origin","text":"The original Python type underlying the type hint.","title":"origin"},{"location":"api/typeapi.deconstruct/#nparams","text":"The number of type parameters that the origin type accepts.","title":"nparams"},{"location":"api/typeapi.deconstruct/#parameters","text":"The type variables from the origin type's original definition. Note that this may be None even if nparams is greater than zero. This is usually the case for special generic aliases like typing.List for which no explicit type variables are defined in the typing module.","title":"parameters"},{"location":"api/typeapi.deconstruct/#args","text":"The type arguments that the origin was parametrized with. This is None if the type is not explicitly parametrized. It may still contain typing.TypeVars if that is what the type was parametrized with.","title":"args"},{"location":"api/typeapi.deconstruct/#with_args","text":"def with_args ( args : t . Tuple [ TypeArg , ... ]) -> TypeInfo [view_source] Return a copy of the TypeInfo object, but args replaced by the args parameter value.","title":"with_args"},{"location":"api/typeapi.deconstruct/#deconstruct_type","text":"def deconstruct_type ( type_ : t . Any ) -> TypeInfo [view_source] Deconstruct a type hint that is not a typing \"special form\" or another type of exotic hint, i.e. a hint that an actual singular type, and return its TypeInfo . Arguments : type_ any - The type hint to deconstruct. Raises : ValueError - If the type_ parameter cannot be deconstructed into a TypeInfo . For example, passing a typing.Annotated object or typing.ClassVar will cause this error to be raised. Example : import collections.abc import typing from typeapi.deconstruct import deconstruct_type , TypeInfo T = typing . TypeVar ( 'T' ) assert deconstruct_type ( typing . Any ) == TypeInfo ( object , 0 , None , None ) assert deconstruct_type ( typing . List ) == TypeInfo ( list , 1 , None , None ) assert deconstruct_type ( t . Mapping [ str , int ]) == TypeInfo ( collections . abc . Mapping , 2 , None , ( str , int ,)) class MyGeneric ( t . Generic [ T ]): pass assert deconstruct_type ( MyGeneric ) == TypeInfo ( MyGeneric , 1 , ( T ,), None ) assert deconstruct_type ( MyGeneric [ int ]) == TypeInfo ( MyGeneric , 1 , ( T ,), ( int ,)) assert deconstruct_type ( MyGeneric [ T ]) == TypeInfo ( MyGeneric , 1 , ( T ,), ( T ,))","title":"deconstruct_type"},{"location":"api/typeapi.utils/","text":"Provides utilities to introspect typing type hints. The goal is to assign the same semantics to all viable members of the typing module independent of the Python version. is_generic def is_generic ( hint : t . Any ) -> te . TypeGuard [ t . Type [ Generic ]] [view_source] Returns : True if hint is a subclass fo typing.Generic (and not an alias of it). is_generic_alias def is_generic_alias ( hint : t . Any ) -> te . TypeGuard [ GenericAlias ] [view_source] Returns : True if hint is a typing._GenericAlias or types.GenericAlias ( PEP 585 since Python 3.10+). !!! note In Python versions 3.8 and older, typing._GenericAlias is used also for special generic aliases (see is_special_generic_alias() ). This function will return False for these types of aliases to clearly distinct between special aliases and normal aliases, even if they share the same type. is_union_type def is_union_type ( hint : t . Any ) -> te . TypeGuard [ UnionType ] [view_source] Returns : True if hint is a typing.Union or types.UnionType . is_special_generic_alias def is_special_generic_alias ( hint : t . Any ) -> te . TypeGuard [ SpecialGenericAlias ] [view_source] Returns : True if hint is a typing._SpecialGenericAlias (like typing.List or typing.Mapping ). !!! note For Python versions 3.8 and older, the function treats typing._GenericAliases as special if their _special attribute is set to True . typing._SpecialGenericAlias was introduced in Python 3.9. is_special_form def is_special_form ( hint : t . Any ) -> te . TypeGuard [ SpecialGenericAlias ] [view_source] Returns : True if hint is a typing._SpecialForm (like typing.Final or typing.Union ). is_annotated_alias def is_annotated_alias ( hint : t . Any ) -> te . TypeGuard [ AnnotatedAlias ] [view_source] Returns : True if hint is a typing._AnnotatedAlias (e.g. typing.Annotated[int, 42] ). is_new_type def is_new_type ( hint : t . Any ) -> te . TypeGuard [ NewType ] [view_source] Returns : True if hint is a typing.NewType object. get_special_generic_aliases @functools . lru_cache () def get_special_generic_aliases () -> t . Dict [ str , SpecialGenericAlias ] [view_source] Returns a dictionary that contains all special generic aliases (like typing.List and typing.Mapping ) defined in the typing module. Example : import typing from typeapi.utils import get_special_generic_aliases mapping = get_special_generic_aliases () assert mapping [ 'List' ] is typing . List get_origins_to_special_generic_aliases @functools . lru_cache () def get_origins_to_special_generic_aliases ( ) -> t . Dict [ type , SpecialGenericAlias ] [view_source] Returns a dictionary that maps a native Python type to the typing special generic alias. Example : import typing from typeapi.utils import get_origins_to_special_generic_aliases mapping = get_origins_to_special_generic_aliases () assert mapping [ list ] is typing . List get_special_forms @functools . lru_cache () def get_special_forms () -> t . Dict [ str , SpecialGenericAlias ] [view_source] Returns a dictionary that contains all special forms (like typing.Final and typing.Union ) defined in the typing module. Example : import typing from typeapi.utils import get_special_forms mapping = get_special_forms () assert mapping [ 'Any' ] is typing . Any assert mapping [ 'Union' ] is typing . Union type_repr def type_repr ( obj ) [view_source] typing._type_repr() stolen from Python 3.8. get_type_hints def get_type_hints ( type_ : t . Any ) -> t . Dict [ str , t . Any ] [view_source] Like typing.get_type_hints() , but always includes extras. This is important when we want to inspect typing.Annotated hints (without extras the annotations are removed).","title":"typeapi.utils"},{"location":"api/typeapi.utils/#is_generic","text":"def is_generic ( hint : t . Any ) -> te . TypeGuard [ t . Type [ Generic ]] [view_source] Returns : True if hint is a subclass fo typing.Generic (and not an alias of it).","title":"is_generic"},{"location":"api/typeapi.utils/#is_generic_alias","text":"def is_generic_alias ( hint : t . Any ) -> te . TypeGuard [ GenericAlias ] [view_source] Returns : True if hint is a typing._GenericAlias or types.GenericAlias ( PEP 585 since Python 3.10+). !!! note In Python versions 3.8 and older, typing._GenericAlias is used also for special generic aliases (see is_special_generic_alias() ). This function will return False for these types of aliases to clearly distinct between special aliases and normal aliases, even if they share the same type.","title":"is_generic_alias"},{"location":"api/typeapi.utils/#is_union_type","text":"def is_union_type ( hint : t . Any ) -> te . TypeGuard [ UnionType ] [view_source] Returns : True if hint is a typing.Union or types.UnionType .","title":"is_union_type"},{"location":"api/typeapi.utils/#is_special_generic_alias","text":"def is_special_generic_alias ( hint : t . Any ) -> te . TypeGuard [ SpecialGenericAlias ] [view_source] Returns : True if hint is a typing._SpecialGenericAlias (like typing.List or typing.Mapping ). !!! note For Python versions 3.8 and older, the function treats typing._GenericAliases as special if their _special attribute is set to True . typing._SpecialGenericAlias was introduced in Python 3.9.","title":"is_special_generic_alias"},{"location":"api/typeapi.utils/#is_special_form","text":"def is_special_form ( hint : t . Any ) -> te . TypeGuard [ SpecialGenericAlias ] [view_source] Returns : True if hint is a typing._SpecialForm (like typing.Final or typing.Union ).","title":"is_special_form"},{"location":"api/typeapi.utils/#is_annotated_alias","text":"def is_annotated_alias ( hint : t . Any ) -> te . TypeGuard [ AnnotatedAlias ] [view_source] Returns : True if hint is a typing._AnnotatedAlias (e.g. typing.Annotated[int, 42] ).","title":"is_annotated_alias"},{"location":"api/typeapi.utils/#is_new_type","text":"def is_new_type ( hint : t . Any ) -> te . TypeGuard [ NewType ] [view_source] Returns : True if hint is a typing.NewType object.","title":"is_new_type"},{"location":"api/typeapi.utils/#get_special_generic_aliases","text":"@functools . lru_cache () def get_special_generic_aliases () -> t . Dict [ str , SpecialGenericAlias ] [view_source] Returns a dictionary that contains all special generic aliases (like typing.List and typing.Mapping ) defined in the typing module. Example : import typing from typeapi.utils import get_special_generic_aliases mapping = get_special_generic_aliases () assert mapping [ 'List' ] is typing . List","title":"get_special_generic_aliases"},{"location":"api/typeapi.utils/#get_origins_to_special_generic_aliases","text":"@functools . lru_cache () def get_origins_to_special_generic_aliases ( ) -> t . Dict [ type , SpecialGenericAlias ] [view_source] Returns a dictionary that maps a native Python type to the typing special generic alias. Example : import typing from typeapi.utils import get_origins_to_special_generic_aliases mapping = get_origins_to_special_generic_aliases () assert mapping [ list ] is typing . List","title":"get_origins_to_special_generic_aliases"},{"location":"api/typeapi.utils/#get_special_forms","text":"@functools . lru_cache () def get_special_forms () -> t . Dict [ str , SpecialGenericAlias ] [view_source] Returns a dictionary that contains all special forms (like typing.Final and typing.Union ) defined in the typing module. Example : import typing from typeapi.utils import get_special_forms mapping = get_special_forms () assert mapping [ 'Any' ] is typing . Any assert mapping [ 'Union' ] is typing . Union","title":"get_special_forms"},{"location":"api/typeapi.utils/#type_repr","text":"def type_repr ( obj ) [view_source] typing._type_repr() stolen from Python 3.8.","title":"type_repr"},{"location":"api/typeapi.utils/#get_type_hints","text":"def get_type_hints ( type_ : t . Any ) -> t . Dict [ str , t . Any ] [view_source] Like typing.get_type_hints() , but always includes extras. This is important when we want to inspect typing.Annotated hints (without extras the annotations are removed).","title":"get_type_hints"}]}