{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"typeapi Typeapi provides a stable and documented API to introspect Python typing type hints. Installation $ pip install typeapi Quickstart import typing import typeapi print ( typeapi . of ( typing . Any )) # Type(object) print ( typeapi . of ( typing . List )) # Type(list) print ( typeapi . of ( typing . Mapping [ str , int ])) # Type(collections.abc.Mapping, (Type(str), Type(int))) print ( typeapi . of ( typing . Union [ str , int ])) # Union(int, str) print ( typeapi . of ( str | int )) # Union(int, str) print ( typeapi . of ( str | int | None )) # Optional(Union[int, str]) print ( typeapi . of ( typing . Annotated [ int , 42 ])) # Annotated(int, 42) print ( typeapi . of ( typing . Annotated [ int , 42 ])) # Annotated(int, 42) print ( typeapi . of ( 'str' , __name__ )) # Type(str)","title":"Home"},{"location":"#typeapi","text":"Typeapi provides a stable and documented API to introspect Python typing type hints.","title":"typeapi"},{"location":"#installation","text":"$ pip install typeapi","title":"Installation"},{"location":"#quickstart","text":"import typing import typeapi print ( typeapi . of ( typing . Any )) # Type(object) print ( typeapi . of ( typing . List )) # Type(list) print ( typeapi . of ( typing . Mapping [ str , int ])) # Type(collections.abc.Mapping, (Type(str), Type(int))) print ( typeapi . of ( typing . Union [ str , int ])) # Union(int, str) print ( typeapi . of ( str | int )) # Union(int, str) print ( typeapi . of ( str | int | None )) # Optional(Union[int, str]) print ( typeapi . of ( typing . Annotated [ int , 42 ])) # Annotated(int, 42) print ( typeapi . of ( typing . Annotated [ int , 42 ])) # Annotated(int, 42) print ( typeapi . of ( 'str' , __name__ )) # Type(str)","title":"Quickstart"},{"location":"changelog/","text":"Unreleased Type Description PR Issues Author Fix fix `from typeapi import *` @NiklasRosenstein 0.1.0a3 (2022-03-15) Type Description PR Issues Author Breaking change remove `Type.args` field and instead make it a property @NiklasRosenstein Breaking change Added `Type.info` property @NiklasRosenstein Feature `deconstruct_type()` now supports concrete types @NiklasRosenstein Feature export members from `typeapi.api`, `typeapi.parser` and `typeapi.deconstruct`, most notably `typeapi.of()` is not available as an alias for `typeapi.parser.parse_type_hint()` @NiklasRosenstein Breaking change remove `Hint.source` @NiklasRosenstein Breaking change remove `typeapi.deconstruct` module, make `typeapi.model.Type` have the fields that `TypeInfo` used to have and move `deconstruct_type()` to `Type.of()` @NiklasRosenstein 0.1.0a2 (2022-03-15) Type Description PR Issues Author Breaking change add `Hint.source` field @NiklasRosenstein","title":"Changelog"},{"location":"changelog/#unreleased","text":"Type Description PR Issues Author Fix fix `from typeapi import *` @NiklasRosenstein","title":"Unreleased"},{"location":"changelog/#010a3-2022-03-15","text":"Type Description PR Issues Author Breaking change remove `Type.args` field and instead make it a property @NiklasRosenstein Breaking change Added `Type.info` property @NiklasRosenstein Feature `deconstruct_type()` now supports concrete types @NiklasRosenstein Feature export members from `typeapi.api`, `typeapi.parser` and `typeapi.deconstruct`, most notably `typeapi.of()` is not available as an alias for `typeapi.parser.parse_type_hint()` @NiklasRosenstein Breaking change remove `Hint.source` @NiklasRosenstein Breaking change remove `typeapi.deconstruct` module, make `typeapi.model.Type` have the fields that `TypeInfo` used to have and move `deconstruct_type()` to `Type.of()` @NiklasRosenstein","title":"0.1.0a3 (2022-03-15)"},{"location":"changelog/#010a2-2022-03-15","text":"Type Description PR Issues Author Breaking change add `Hint.source` field @NiklasRosenstein","title":"0.1.0a2 (2022-03-15)"},{"location":"api/typeapi/","text":"The typeapi module provides a stable API to introspect Python typing type hints. Example : import typeapi , typing hint = typeapi . of ( typing . List [ int ]) assert hint == typeapi . Type ( list , nparams = 1 , parameters = None , args = ( int ,)) hint = typeapi . of ( int | str | None ) assert hint == typeapi . Union (( int , str , type ( None ))) The typeapi.of() function introspects the type hint passed as an argument and converts it to a stable description using the dataclasses defined in typeapi.model .","title":"typeapi"},{"location":"api/typeapi.model/","text":"Class Hint class Hint () [view_source] Base for classes that represent type hints. Class Type @dataclasses . dataclass class Type ( Hint ) [view_source] Represents a concrete type, including type arguments if applicable. type The original Python type underlying the type hint. nparams The number of type parameters that the origin type accepts. parameters The type variables from the origin type's original definition. Note that this may be None even if nparams is greater than zero. This is usually the case for special generic aliases like typing.List for which no explicit type variables are defined in the typing module. args The type arguments that the origin was parametrized with. This is None if the type is not explicitly parametrized. It may still contain typing.TypeVars if that is what the type was parametrized with. with_args def with_args ( args : t . Tuple [ utils . TypeArg , ... ]) -> Type [view_source] Return a copy of the Type object, but args replaced by the args parameter value. of @staticmethod def of ( type_ : t . Any ) -> Type [view_source] Deconstruct a type hint that is concrete type or generic alias, i.e. one that is not a \"special form\" like typing.Union or typing.Any . Examples of types being accepted are any actual Python types, typing.Any , special generic aliases like typing.List (unspecialized) or generic aliases (like typing.List[int] or a parametrization of a typing.Generic subclass). Arguments : type_ any - The type hint to deconstruct. Raises : ValueError - If the type_ parameter cannot be deconstructed into a Type . For example, passing a typing.Annotated object or typing.ClassVar will cause this error to be raised. Class Union @dataclasses . dataclass class Union ( Hint ) [view_source] Represents typing.Union or typing.Optional . types The types in this union. Class Annotated @dataclasses . dataclass class Annotated ( Hint ) [view_source] Represents a type wrapped in typing.Annotated . wrapped The type that is annotated. metadata The metadata in the annotation. Class ForwardRef @dataclasses . dataclass class ForwardRef ( Hint ) [view_source] Represents a forward reference. expr The expression of the forward reference. module The module that is associated with the forward reference. Class Any @dataclasses . dataclass class Any ( Hint ) [view_source] Represents typing.Any . Class ClassVar @dataclasses . dataclass class ClassVar ( Hint ) [view_source] Represents typing.ClassVar . wrapped The inner type. Class Final @dataclasses . dataclass class Final ( Hint ) [view_source] Represents typing.Final . wrapped The inner type. Class NoReturn @dataclasses . dataclass class NoReturn ( Hint ) [view_source] Represents typing.NoReturn . Class TypeGuard @dataclasses . dataclass class TypeGuard ( Hint ) [view_source] Represents typing.TypeGuard . wrapped The wrapped type. Class Literal @dataclasses . dataclass class Literal ( Hint ) [view_source] Represents typing.Literal . values The possible values represented by the literal. Class NewType @dataclasses . dataclass class NewType ( Hint ) [view_source] Represents typing.NewType . name The name of the new type. supertype The underlying type for the new type. Class Unknown @dataclasses . dataclass class Unknown ( Hint ) [view_source] Represents an type hint that is not understood. hint The type hint that could not be converted into the typeapi.","title":"typeapi.model"},{"location":"api/typeapi.model/#class-hint","text":"class Hint () [view_source] Base for classes that represent type hints.","title":"Class Hint"},{"location":"api/typeapi.model/#class-type","text":"@dataclasses . dataclass class Type ( Hint ) [view_source] Represents a concrete type, including type arguments if applicable.","title":"Class Type"},{"location":"api/typeapi.model/#type","text":"The original Python type underlying the type hint.","title":"type"},{"location":"api/typeapi.model/#nparams","text":"The number of type parameters that the origin type accepts.","title":"nparams"},{"location":"api/typeapi.model/#parameters","text":"The type variables from the origin type's original definition. Note that this may be None even if nparams is greater than zero. This is usually the case for special generic aliases like typing.List for which no explicit type variables are defined in the typing module.","title":"parameters"},{"location":"api/typeapi.model/#args","text":"The type arguments that the origin was parametrized with. This is None if the type is not explicitly parametrized. It may still contain typing.TypeVars if that is what the type was parametrized with.","title":"args"},{"location":"api/typeapi.model/#with_args","text":"def with_args ( args : t . Tuple [ utils . TypeArg , ... ]) -> Type [view_source] Return a copy of the Type object, but args replaced by the args parameter value.","title":"with_args"},{"location":"api/typeapi.model/#of","text":"@staticmethod def of ( type_ : t . Any ) -> Type [view_source] Deconstruct a type hint that is concrete type or generic alias, i.e. one that is not a \"special form\" like typing.Union or typing.Any . Examples of types being accepted are any actual Python types, typing.Any , special generic aliases like typing.List (unspecialized) or generic aliases (like typing.List[int] or a parametrization of a typing.Generic subclass). Arguments : type_ any - The type hint to deconstruct. Raises : ValueError - If the type_ parameter cannot be deconstructed into a Type . For example, passing a typing.Annotated object or typing.ClassVar will cause this error to be raised.","title":"of"},{"location":"api/typeapi.model/#class-union","text":"@dataclasses . dataclass class Union ( Hint ) [view_source] Represents typing.Union or typing.Optional .","title":"Class Union"},{"location":"api/typeapi.model/#types","text":"The types in this union.","title":"types"},{"location":"api/typeapi.model/#class-annotated","text":"@dataclasses . dataclass class Annotated ( Hint ) [view_source] Represents a type wrapped in typing.Annotated .","title":"Class Annotated"},{"location":"api/typeapi.model/#wrapped","text":"The type that is annotated.","title":"wrapped"},{"location":"api/typeapi.model/#metadata","text":"The metadata in the annotation.","title":"metadata"},{"location":"api/typeapi.model/#class-forwardref","text":"@dataclasses . dataclass class ForwardRef ( Hint ) [view_source] Represents a forward reference.","title":"Class ForwardRef"},{"location":"api/typeapi.model/#expr","text":"The expression of the forward reference.","title":"expr"},{"location":"api/typeapi.model/#module","text":"The module that is associated with the forward reference.","title":"module"},{"location":"api/typeapi.model/#class-any","text":"@dataclasses . dataclass class Any ( Hint ) [view_source] Represents typing.Any .","title":"Class Any"},{"location":"api/typeapi.model/#class-classvar","text":"@dataclasses . dataclass class ClassVar ( Hint ) [view_source] Represents typing.ClassVar .","title":"Class ClassVar"},{"location":"api/typeapi.model/#wrapped_1","text":"The inner type.","title":"wrapped"},{"location":"api/typeapi.model/#class-final","text":"@dataclasses . dataclass class Final ( Hint ) [view_source] Represents typing.Final .","title":"Class Final"},{"location":"api/typeapi.model/#wrapped_2","text":"The inner type.","title":"wrapped"},{"location":"api/typeapi.model/#class-noreturn","text":"@dataclasses . dataclass class NoReturn ( Hint ) [view_source] Represents typing.NoReturn .","title":"Class NoReturn"},{"location":"api/typeapi.model/#class-typeguard","text":"@dataclasses . dataclass class TypeGuard ( Hint ) [view_source] Represents typing.TypeGuard .","title":"Class TypeGuard"},{"location":"api/typeapi.model/#wrapped_3","text":"The wrapped type.","title":"wrapped"},{"location":"api/typeapi.model/#class-literal","text":"@dataclasses . dataclass class Literal ( Hint ) [view_source] Represents typing.Literal .","title":"Class Literal"},{"location":"api/typeapi.model/#values","text":"The possible values represented by the literal.","title":"values"},{"location":"api/typeapi.model/#class-newtype","text":"@dataclasses . dataclass class NewType ( Hint ) [view_source] Represents typing.NewType .","title":"Class NewType"},{"location":"api/typeapi.model/#name","text":"The name of the new type.","title":"name"},{"location":"api/typeapi.model/#supertype","text":"The underlying type for the new type.","title":"supertype"},{"location":"api/typeapi.model/#class-unknown","text":"@dataclasses . dataclass class Unknown ( Hint ) [view_source] Represents an type hint that is not understood.","title":"Class Unknown"},{"location":"api/typeapi.model/#hint","text":"The type hint that could not be converted into the typeapi.","title":"hint"},{"location":"api/typeapi.parser/","text":"parse_type_hint @t . overload def parse_type_hint ( hint : t . Any ) -> Hint [view_source] Parse the given type hint to a Hint object. If the type hint is not accepted by any of the handlers, an instance of Unknown is returned instead. Arguments : hint - The type hint to adapt. Returns : A Hint object that should make it easier to introspect the type hint with a stable API. parse_type_hint @t . overload def parse_type_hint ( hint : t . Any , * , debug : te . Literal [ True ]) -> t . Tuple [ Hint , t . Optional [ str ]] [view_source] Same as parse_type_hint() , but returns the name of the handler function that accepted the type hint and converted it to a Hint object.","title":"typeapi.parser"},{"location":"api/typeapi.parser/#parse_type_hint","text":"@t . overload def parse_type_hint ( hint : t . Any ) -> Hint [view_source] Parse the given type hint to a Hint object. If the type hint is not accepted by any of the handlers, an instance of Unknown is returned instead. Arguments : hint - The type hint to adapt. Returns : A Hint object that should make it easier to introspect the type hint with a stable API.","title":"parse_type_hint"},{"location":"api/typeapi.parser/#parse_type_hint_1","text":"@t . overload def parse_type_hint ( hint : t . Any , * , debug : te . Literal [ True ]) -> t . Tuple [ Hint , t . Optional [ str ]] [view_source] Same as parse_type_hint() , but returns the name of the handler function that accepted the type hint and converted it to a Hint object.","title":"parse_type_hint"},{"location":"api/typeapi.utils/","text":"Provides utilities to introspect typing type hints. The goal is to assign the same semantics to all viable members of the typing module independent of the Python version. is_generic def is_generic ( hint : t . Any ) -> te . TypeGuard [ t . Type [ Generic ]] [view_source] Returns : True if hint is a subclass fo typing.Generic (and not an alias of it). is_generic_alias def is_generic_alias ( hint : t . Any ) -> te . TypeGuard [ GenericAlias ] [view_source] Returns : True if hint is a typing._GenericAlias or types.GenericAlias ( PEP 585 since Python 3.10+). !!! note In Python versions 3.8 and older, typing._GenericAlias is used also for special generic aliases (see is_special_generic_alias() ). This function will return False for these types of aliases to clearly distinct between special aliases and normal aliases, even if they share the same type. is_union_type def is_union_type ( hint : t . Any ) -> te . TypeGuard [ UnionType ] [view_source] Returns : True if hint is a typing.Union or types.UnionType . is_special_generic_alias def is_special_generic_alias ( hint : t . Any ) -> te . TypeGuard [ SpecialGenericAlias ] [view_source] Returns : True if hint is a typing._SpecialGenericAlias (like typing.List or typing.Mapping ). !!! note For Python versions 3.8 and older, the function treats typing._GenericAliases as special if their _special attribute is set to True . typing._SpecialGenericAlias was introduced in Python 3.9. is_special_form def is_special_form ( hint : t . Any ) -> te . TypeGuard [ SpecialGenericAlias ] [view_source] Returns : True if hint is a typing._SpecialForm (like typing.Final or typing.Union ). is_annotated_alias def is_annotated_alias ( hint : t . Any ) -> te . TypeGuard [ AnnotatedAlias ] [view_source] Returns : True if hint is a typing._AnnotatedAlias (e.g. typing.Annotated[int, 42] ). is_new_type def is_new_type ( hint : t . Any ) -> te . TypeGuard [ NewType ] [view_source] Returns : True if hint is a typing.NewType object. get_special_generic_aliases @functools . lru_cache () def get_special_generic_aliases () -> t . Dict [ str , SpecialGenericAlias ] [view_source] Returns a dictionary that contains all special generic aliases (like typing.List and typing.Mapping ) defined in the typing module. Example : import typing from typeapi.utils import get_special_generic_aliases mapping = get_special_generic_aliases () assert mapping [ 'List' ] is typing . List get_origins_to_special_generic_aliases @functools . lru_cache () def get_origins_to_special_generic_aliases ( ) -> t . Dict [ type , SpecialGenericAlias ] [view_source] Returns a dictionary that maps a native Python type to the typing special generic alias. Example : import typing from typeapi.utils import get_origins_to_special_generic_aliases mapping = get_origins_to_special_generic_aliases () assert mapping [ list ] is typing . List get_special_forms @functools . lru_cache () def get_special_forms () -> t . Dict [ str , SpecialGenericAlias ] [view_source] Returns a dictionary that contains all special forms (like typing.Final and typing.Union ) defined in the typing module. Example : import typing from typeapi.utils import get_special_forms mapping = get_special_forms () assert mapping [ 'Any' ] is typing . Any assert mapping [ 'Union' ] is typing . Union type_repr def type_repr ( obj ) [view_source] typing._type_repr() stolen from Python 3.8. get_type_hints def get_type_hints ( type_ : t . Any ) -> t . Dict [ str , t . Any ] [view_source] Like typing.get_type_hints() , but always includes extras. This is important when we want to inspect typing.Annotated hints (without extras the annotations are removed).","title":"typeapi.utils"},{"location":"api/typeapi.utils/#is_generic","text":"def is_generic ( hint : t . Any ) -> te . TypeGuard [ t . Type [ Generic ]] [view_source] Returns : True if hint is a subclass fo typing.Generic (and not an alias of it).","title":"is_generic"},{"location":"api/typeapi.utils/#is_generic_alias","text":"def is_generic_alias ( hint : t . Any ) -> te . TypeGuard [ GenericAlias ] [view_source] Returns : True if hint is a typing._GenericAlias or types.GenericAlias ( PEP 585 since Python 3.10+). !!! note In Python versions 3.8 and older, typing._GenericAlias is used also for special generic aliases (see is_special_generic_alias() ). This function will return False for these types of aliases to clearly distinct between special aliases and normal aliases, even if they share the same type.","title":"is_generic_alias"},{"location":"api/typeapi.utils/#is_union_type","text":"def is_union_type ( hint : t . Any ) -> te . TypeGuard [ UnionType ] [view_source] Returns : True if hint is a typing.Union or types.UnionType .","title":"is_union_type"},{"location":"api/typeapi.utils/#is_special_generic_alias","text":"def is_special_generic_alias ( hint : t . Any ) -> te . TypeGuard [ SpecialGenericAlias ] [view_source] Returns : True if hint is a typing._SpecialGenericAlias (like typing.List or typing.Mapping ). !!! note For Python versions 3.8 and older, the function treats typing._GenericAliases as special if their _special attribute is set to True . typing._SpecialGenericAlias was introduced in Python 3.9.","title":"is_special_generic_alias"},{"location":"api/typeapi.utils/#is_special_form","text":"def is_special_form ( hint : t . Any ) -> te . TypeGuard [ SpecialGenericAlias ] [view_source] Returns : True if hint is a typing._SpecialForm (like typing.Final or typing.Union ).","title":"is_special_form"},{"location":"api/typeapi.utils/#is_annotated_alias","text":"def is_annotated_alias ( hint : t . Any ) -> te . TypeGuard [ AnnotatedAlias ] [view_source] Returns : True if hint is a typing._AnnotatedAlias (e.g. typing.Annotated[int, 42] ).","title":"is_annotated_alias"},{"location":"api/typeapi.utils/#is_new_type","text":"def is_new_type ( hint : t . Any ) -> te . TypeGuard [ NewType ] [view_source] Returns : True if hint is a typing.NewType object.","title":"is_new_type"},{"location":"api/typeapi.utils/#get_special_generic_aliases","text":"@functools . lru_cache () def get_special_generic_aliases () -> t . Dict [ str , SpecialGenericAlias ] [view_source] Returns a dictionary that contains all special generic aliases (like typing.List and typing.Mapping ) defined in the typing module. Example : import typing from typeapi.utils import get_special_generic_aliases mapping = get_special_generic_aliases () assert mapping [ 'List' ] is typing . List","title":"get_special_generic_aliases"},{"location":"api/typeapi.utils/#get_origins_to_special_generic_aliases","text":"@functools . lru_cache () def get_origins_to_special_generic_aliases ( ) -> t . Dict [ type , SpecialGenericAlias ] [view_source] Returns a dictionary that maps a native Python type to the typing special generic alias. Example : import typing from typeapi.utils import get_origins_to_special_generic_aliases mapping = get_origins_to_special_generic_aliases () assert mapping [ list ] is typing . List","title":"get_origins_to_special_generic_aliases"},{"location":"api/typeapi.utils/#get_special_forms","text":"@functools . lru_cache () def get_special_forms () -> t . Dict [ str , SpecialGenericAlias ] [view_source] Returns a dictionary that contains all special forms (like typing.Final and typing.Union ) defined in the typing module. Example : import typing from typeapi.utils import get_special_forms mapping = get_special_forms () assert mapping [ 'Any' ] is typing . Any assert mapping [ 'Union' ] is typing . Union","title":"get_special_forms"},{"location":"api/typeapi.utils/#type_repr","text":"def type_repr ( obj ) [view_source] typing._type_repr() stolen from Python 3.8.","title":"type_repr"},{"location":"api/typeapi.utils/#get_type_hints","text":"def get_type_hints ( type_ : t . Any ) -> t . Dict [ str , t . Any ] [view_source] Like typing.get_type_hints() , but always includes extras. This is important when we want to inspect typing.Annotated hints (without extras the annotations are removed).","title":"get_type_hints"}]}