{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"typeapi This library provides a stable API to introspect Python's typing and typing_extensions type hints. Installation $ pip install typeapi Example import typing , typeapi print ( typeapi . of ( typing . Mapping [ typing . Annotated [ str , \"key\" ], typing . Literal [ True , None , 'false' ]])) # Type(collections.abc.Mapping, nparams=2, args=(Annotated(Type(str, nparams=0), 'key'), Literal(values=(True, None, 'false'))))","title":"Home"},{"location":"#typeapi","text":"This library provides a stable API to introspect Python's typing and typing_extensions type hints.","title":"typeapi"},{"location":"#installation","text":"$ pip install typeapi","title":"Installation"},{"location":"#example","text":"import typing , typeapi print ( typeapi . of ( typing . Mapping [ typing . Annotated [ str , \"key\" ], typing . Literal [ True , None , 'false' ]])) # Type(collections.abc.Mapping, nparams=2, args=(Annotated(Type(str, nparams=0), 'key'), Literal(values=(True, None, 'false'))))","title":"Example"},{"location":"changelog/","text":"Unreleased Type Description PR Issues Author Improvement Enable strict type checking in Mypy @NiklasRosenstein 0.2.0 (2022-05-29) Type Description PR Issues Author Improvement Limit types accepted for `typeapi.get_annotations() to modules, types and callables as is also the case in `inspect.get_annotations()` starting with 3.10 @NiklasRosenstein 0.1.6 (2022-04-19) Type Description PR Issues Author Feature Add `recursive` argument to `ForwardRef.evaluate()` @NiklasRosenstein Feature Add `ignore_name_errors` to `eval_types()` @NiklasRosenstein 0.1.5 (2022-03-23) Type Description PR Issues Author Feature add `typeapi.utils.scope()` @NiklasRosenstein 0.1.4 (2022-03-23) Type Description PR Issues Author Feature add `typeapi.utils.unwrap()` @NiklasRosenstein 0.1.3 (2022-03-23) Type Description PR Issues Author Feature add `globalns` and `localns` parameters to `get_annotations()` and `ForwardRef.evaluate()` @NiklasRosenstein Feature add `typeapi.utils.scoped()` decorator @NiklasRosenstein 0.1.2 (2022-03-22) Type Description PR Issues Author Improvement add `get_annotations(include_bases)` parameter @NiklasRosenstein Improvement update `ForweardRef.__repr__()` @NiklasRosenstein 0.1.1 (2022-03-17) Type Description PR Issues Author Fix Fix an error caused when using `Type.get_orig_bases()` if the `Type.type` has non-generic bases @NiklasRosenstein Deprecation Deprecated `get_type_hints()` in favor of new `get_annotations()` @NiklasRosenstein Fix Fix `get_annotations()` in Python 3.9 and older to have the same behaviour as `inspect.get_annotations()` in that it does not include annotations of a classes' bases @NiklasRosenstein Feature Add `typeapi.utils.is_typed_dict()` and the `typeapi.utils.TypedDict` protocol @NiklasRosenstein 0.1.0 (2022-03-17) Type Description PR Issues Author Feature Add `Type.get_orig_bases()` @NiklasRosenstein Feature Add `Type.get_orig_bases_parametrized()` @NiklasRosenstein Fix Fix `infuse_type_parameters()` to replace sole `typeapi.TypeVar` instead of only occurrences in `typeapi.Type.args` @NiklasRosenstein Fix Fix `infuse_type_parameters()` to replace sole `typeapi.TypeVar` instead of only occurrences in `typeapi.Type.args` @NiklasRosenstein Fix Fix `Type.get_parameter_mapping()` return annotation @NiklasRosenstein Fix Fix `infuse_type_parameters()` to handle plain `typeapi.TypeVar` and not just the like in `typeapi.Type.args` @NiklasRosenstein 0.1.0a5 (2022-03-17) Type Description PR Issues Author Breaking change Change `ForwardRef` and `NewType` to hold the origin `typing` object @NiklasRosenstein Feature Implement `ForwardRef.evaluate()` @NiklasRosenstein Feature add `typeapi.eval_types()` @NiklasRosenstein Feature add `typeapi.infuse_type_parameters()` @NiklasRosenstein 0.1.0a4 (2022-03-17) Type Description PR Issues Author Fix fix `from typeapi import *` @NiklasRosenstein Improvement export `get_type_hints()` and `type_repr()` in `typeapi` root module @NiklasRosenstein Improvement `is_generic()` no longer returns true if the type is the actualy `typing.Generic` because only its subclasses of `__parameters__` @NiklasRosenstein Fix `Type.of()` no longer errors on passing `typing.Generic` and handles it as `Type(typing.Generic, 0, None, None)` @NiklasRosenstein Feature Add `Type.get_parameter_mapping()` @NiklasRosenstein Breaking change Type hints are now converted recursively, all recursive API models now store `Hint` objects directly instead of the raw typing argument. @NiklasRosenstein 0.1.0a3 (2022-03-15) Type Description PR Issues Author Breaking change remove `Type.args` field and instead make it a property @NiklasRosenstein Breaking change Added `Type.info` property @NiklasRosenstein Feature `deconstruct_type()` now supports concrete types @NiklasRosenstein Feature export members from `typeapi.api`, `typeapi.parser` and `typeapi.deconstruct`, most notably `typeapi.of()` is not available as an alias for `typeapi.parser.parse_type_hint()` @NiklasRosenstein Breaking change remove `Hint.source` @NiklasRosenstein Breaking change remove `typeapi.deconstruct` module, make `typeapi.model.Type` have the fields that `TypeInfo` used to have and move `deconstruct_type()` to `Type.of()` @NiklasRosenstein 0.1.0a2 (2022-03-15) Type Description PR Issues Author Breaking change add `Hint.source` field @NiklasRosenstein","title":"Changelog"},{"location":"changelog/#unreleased","text":"Type Description PR Issues Author Improvement Enable strict type checking in Mypy @NiklasRosenstein","title":"Unreleased"},{"location":"changelog/#020-2022-05-29","text":"Type Description PR Issues Author Improvement Limit types accepted for `typeapi.get_annotations() to modules, types and callables as is also the case in `inspect.get_annotations()` starting with 3.10 @NiklasRosenstein","title":"0.2.0 (2022-05-29)"},{"location":"changelog/#016-2022-04-19","text":"Type Description PR Issues Author Feature Add `recursive` argument to `ForwardRef.evaluate()` @NiklasRosenstein Feature Add `ignore_name_errors` to `eval_types()` @NiklasRosenstein","title":"0.1.6 (2022-04-19)"},{"location":"changelog/#015-2022-03-23","text":"Type Description PR Issues Author Feature add `typeapi.utils.scope()` @NiklasRosenstein","title":"0.1.5 (2022-03-23)"},{"location":"changelog/#014-2022-03-23","text":"Type Description PR Issues Author Feature add `typeapi.utils.unwrap()` @NiklasRosenstein","title":"0.1.4 (2022-03-23)"},{"location":"changelog/#013-2022-03-23","text":"Type Description PR Issues Author Feature add `globalns` and `localns` parameters to `get_annotations()` and `ForwardRef.evaluate()` @NiklasRosenstein Feature add `typeapi.utils.scoped()` decorator @NiklasRosenstein","title":"0.1.3 (2022-03-23)"},{"location":"changelog/#012-2022-03-22","text":"Type Description PR Issues Author Improvement add `get_annotations(include_bases)` parameter @NiklasRosenstein Improvement update `ForweardRef.__repr__()` @NiklasRosenstein","title":"0.1.2 (2022-03-22)"},{"location":"changelog/#011-2022-03-17","text":"Type Description PR Issues Author Fix Fix an error caused when using `Type.get_orig_bases()` if the `Type.type` has non-generic bases @NiklasRosenstein Deprecation Deprecated `get_type_hints()` in favor of new `get_annotations()` @NiklasRosenstein Fix Fix `get_annotations()` in Python 3.9 and older to have the same behaviour as `inspect.get_annotations()` in that it does not include annotations of a classes' bases @NiklasRosenstein Feature Add `typeapi.utils.is_typed_dict()` and the `typeapi.utils.TypedDict` protocol @NiklasRosenstein","title":"0.1.1 (2022-03-17)"},{"location":"changelog/#010-2022-03-17","text":"Type Description PR Issues Author Feature Add `Type.get_orig_bases()` @NiklasRosenstein Feature Add `Type.get_orig_bases_parametrized()` @NiklasRosenstein Fix Fix `infuse_type_parameters()` to replace sole `typeapi.TypeVar` instead of only occurrences in `typeapi.Type.args` @NiklasRosenstein Fix Fix `infuse_type_parameters()` to replace sole `typeapi.TypeVar` instead of only occurrences in `typeapi.Type.args` @NiklasRosenstein Fix Fix `Type.get_parameter_mapping()` return annotation @NiklasRosenstein Fix Fix `infuse_type_parameters()` to handle plain `typeapi.TypeVar` and not just the like in `typeapi.Type.args` @NiklasRosenstein","title":"0.1.0 (2022-03-17)"},{"location":"changelog/#010a5-2022-03-17","text":"Type Description PR Issues Author Breaking change Change `ForwardRef` and `NewType` to hold the origin `typing` object @NiklasRosenstein Feature Implement `ForwardRef.evaluate()` @NiklasRosenstein Feature add `typeapi.eval_types()` @NiklasRosenstein Feature add `typeapi.infuse_type_parameters()` @NiklasRosenstein","title":"0.1.0a5 (2022-03-17)"},{"location":"changelog/#010a4-2022-03-17","text":"Type Description PR Issues Author Fix fix `from typeapi import *` @NiklasRosenstein Improvement export `get_type_hints()` and `type_repr()` in `typeapi` root module @NiklasRosenstein Improvement `is_generic()` no longer returns true if the type is the actualy `typing.Generic` because only its subclasses of `__parameters__` @NiklasRosenstein Fix `Type.of()` no longer errors on passing `typing.Generic` and handles it as `Type(typing.Generic, 0, None, None)` @NiklasRosenstein Feature Add `Type.get_parameter_mapping()` @NiklasRosenstein Breaking change Type hints are now converted recursively, all recursive API models now store `Hint` objects directly instead of the raw typing argument. @NiklasRosenstein","title":"0.1.0a4 (2022-03-17)"},{"location":"changelog/#010a3-2022-03-15","text":"Type Description PR Issues Author Breaking change remove `Type.args` field and instead make it a property @NiklasRosenstein Breaking change Added `Type.info` property @NiklasRosenstein Feature `deconstruct_type()` now supports concrete types @NiklasRosenstein Feature export members from `typeapi.api`, `typeapi.parser` and `typeapi.deconstruct`, most notably `typeapi.of()` is not available as an alias for `typeapi.parser.parse_type_hint()` @NiklasRosenstein Breaking change remove `Hint.source` @NiklasRosenstein Breaking change remove `typeapi.deconstruct` module, make `typeapi.model.Type` have the fields that `TypeInfo` used to have and move `deconstruct_type()` to `Type.of()` @NiklasRosenstein","title":"0.1.0a3 (2022-03-15)"},{"location":"changelog/#010a2-2022-03-15","text":"Type Description PR Issues Author Breaking change add `Hint.source` field @NiklasRosenstein","title":"0.1.0a2 (2022-03-15)"},{"location":"api/typeapi/","text":"The typeapi module provides a stable API to introspect Python typing type hints. Example : import typeapi , typing hint = typeapi . of ( typing . List [ int ]) assert hint == Type ( list , nparams = 1 , parameters = None , args = ( Type . of ( int ),)) hint = typeapi . of ( int | str | None ) assert hint == typeapi . Union (( Type . of ( int ), Type . of ( str ), Type . of ( type ( None )))) The typeapi.of() function introspects the type hint passed as an argument and converts it to a stable description using the dataclasses defined in typeapi.model .","title":"typeapi"},{"location":"api/typeapi.model/","text":"Class Hint class Hint () [view_source] Base for classes that represent type hints. visit def visit ( func : t . Callable [[ Hint ], Hint ]) -> Hint [view_source] Visit the hint and its subhints, if any, and call func on it. Returns the result of func on self. Class Type @dataclasses . dataclass class Type ( Hint ) [view_source] Represents a concrete type, including type arguments if applicable. type The original Python type underlying the type hint. nparams The number of type parameters that the origin type accepts. parameters The type variables from the origin type's original definition. Note that this may be None even if nparams is greater than zero. This is usually the case for special generic aliases like typing.List for which no explicit type variables are defined in the typing module. args The type arguments that the origin was parametrized with. This is None if the type is not explicitly parametrized. It may still contain typing.TypeVars if that is what the type was parametrized with. with_args def with_args ( args : t . Optional [ t . Tuple [ Hint , ... ]]) -> Type [view_source] Return a copy of the Type object, but args replaced by the args parameter value. get_parameter_mapping def get_parameter_mapping () -> t . Dict [ t . TypeVar , Hint ] [view_source] Computes the values assigned to all type parameters present in type and its bases. get_orig_bases def get_orig_bases ( all_ : bool = False ) -> t . Iterable [ utils . GenericAlias ] [view_source] A generator for the generic aliases that comprise the generic base classes of type . Note that if args is not None , it means this Type object was created from a generic alias, but that generic alias is not returned by this generator. Arguments : all_ - If set to True , all original bases in the entire class hierarchy will be returned. get_orig_bases_parametrized def get_orig_bases_parametrized ( all_ : bool = False ) -> t . Dict [ utils . GenericAlias , Type ] [view_source] Create a dictionary that maps the generic aliases returned by get_orig_bases() to a type hint infused with the current type's args . If the type is not a generic or has no generic bases, this method returns an empty dictionary. Note that this will skip typing.Generic . of @staticmethod def of ( type_ : t . Any ) -> Type [view_source] Deconstruct a type hint that is concrete type or generic alias, i.e. one that is not a \"special form\" like typing.Union or typing.Any . Examples of types being accepted are any actual Python types, typing.Any , special generic aliases like typing.List (unspecialized) or generic aliases (like typing.List[int] or a parametrization of a typing.Generic subclass). Arguments : type_ any - The type hint to deconstruct. Raises : ValueError - If the type_ parameter cannot be deconstructed into a Type . For example, passing a typing.Annotated object or typing.ClassVar will cause this error to be raised. Class Union @dataclasses . dataclass ( repr = False ) class Union ( Hint ) [view_source] Represents typing.Union or typing.Optional . types The types in this union. has_none_type def has_none_type () -> bool [view_source] Returns True if one of the types is a Type representing types.NoneType . without_none_type def without_none_type () -> Hint [view_source] Return a copy but with types not containing a types.NoneType . If there is only one member remaining, that member type hint will be returned directly (because Union must contain at least two members). Class Annotated @dataclasses . dataclass ( repr = False ) class Annotated ( Hint ) [view_source] Represents a type wrapped in typing.Annotated . wrapped The type that is annotated. metadata The metadata in the annotation. Class ForwardRef @dataclasses . dataclass ( repr = False ) class ForwardRef ( Hint ) [view_source] Represents a forward reference. ref The forward reference. expr @property def expr () -> str [view_source] Returns the code from the forward reference. module @property def module () -> t . Optional [ str ] [view_source] Returns the name of the moduel in which the forward reference is to be evaluated. evaluate def evaluate ( fallback_module : t . Optional [ str ] = None , globalns : t . Optional [ t . Dict [ str , t . Any ]] = None , localns : t . Optional [ t . Dict [ str , t . Any ]] = None , recursive : bool = True ) -> t . Any [view_source] Evaluate the forward reference, preferably in the module that is already known by ref , or otherwise in the specified fallback_module or the specified globalns and localns namespaces.. Class Any @dataclasses . dataclass ( repr = False ) class Any ( Hint ) [view_source] Represents typing.Any . Class ClassVar @dataclasses . dataclass ( repr = False ) class ClassVar ( Hint ) [view_source] Represents typing.ClassVar . wrapped The inner type. Class Final @dataclasses . dataclass ( repr = False ) class Final ( Hint ) [view_source] Represents typing.Final . wrapped The inner type. Class NoReturn @dataclasses . dataclass ( repr = False ) class NoReturn ( Hint ) [view_source] Represents typing.NoReturn . Class TypeGuard @dataclasses . dataclass ( repr = False ) class TypeGuard ( Hint ) [view_source] Represents typing.TypeGuard . wrapped The wrapped type. Class Literal @dataclasses . dataclass ( repr = False ) class Literal ( Hint ) [view_source] Represents typing.Literal . values The possible values represented by the literal. Class TypeVar @dataclasses . dataclass ( repr = False ) class TypeVar ( Hint ) [view_source] Represents a typing.TypeVar . var The type variable. Class NewType @dataclasses . dataclass ( repr = False ) class NewType ( Hint ) [view_source] Represents typing.NewType . type The typing new type instance. name @property def name () -> str [view_source] The name of the new type. supertype @property def supertype () -> builtins . type [view_source] The underlying type of the new type. Class Unknown @dataclasses . dataclass ( repr = False ) class Unknown ( Hint ) [view_source] Represents an type hint that is not understood. hint The type hint that could not be converted into the typeapi. eval_types def eval_types ( hint : Hint , module : t . Optional [ str ] = None , globalns : t . Optional [ t . Dict [ str , t . Any ]] = None , localns : t . Optional [ t . Dict [ str , t . Any ]] = None , ignore_name_errors : bool = False ) -> Hint [view_source] Evaluate all forward references present in hint . Arguments : hint - The typeapi Hint to evaluate forward references in. module - The name of the module to evaluate the references in if they are not already associated with a module. Note that the module must be present in sys.modules . globalns - A mapping to serve as a namespace to evaluate forward references in if module is not set and the forward reference has no module reference. localns - Same as globalns but for the local namespace. ignore_name_errors - Ignore NameError exceptions during evaluation and keep the type hint around as a ForwardRef . This is useful if you want to evaluate as much as possible of a type annotation, but don't care so much about resolving everything (e.g. if only the root type hint is of interest). Note the string annotation must in turn contain a string in order for the forward ref to be partiially resolvable (e.g. 'Property[\"Content\"]' ). Returns : The same hint with all forward references replaced. infuse_type_parameters @t . overload def infuse_type_parameters ( hint : Type , parameters : t . Dict [ t . TypeVar , Hint ]) -> Type [view_source] If you already have a Type hint, infusing it returns just another Type . infuse_type_parameters @t . overload def infuse_type_parameters ( hint : Hint , parameters : t . Dict [ t . TypeVar , Hint ]) -> Hint [view_source] Replace type variables in hint with the parameters in the given mapping. unwrap def unwrap ( hint : Hint ) -> t . Tuple [ Hint , t . Tuple [ t . Any , ... ]] [view_source] If given a typing.Annotated hint, returns the wrapped hint and the annotation metadata. Otherwise, the hint is returned as-is and an empty tuple for metadata.","title":"typeapi.model"},{"location":"api/typeapi.model/#class-hint","text":"class Hint () [view_source] Base for classes that represent type hints.","title":"Class Hint"},{"location":"api/typeapi.model/#visit","text":"def visit ( func : t . Callable [[ Hint ], Hint ]) -> Hint [view_source] Visit the hint and its subhints, if any, and call func on it. Returns the result of func on self.","title":"visit"},{"location":"api/typeapi.model/#class-type","text":"@dataclasses . dataclass class Type ( Hint ) [view_source] Represents a concrete type, including type arguments if applicable.","title":"Class Type"},{"location":"api/typeapi.model/#type","text":"The original Python type underlying the type hint.","title":"type"},{"location":"api/typeapi.model/#nparams","text":"The number of type parameters that the origin type accepts.","title":"nparams"},{"location":"api/typeapi.model/#parameters","text":"The type variables from the origin type's original definition. Note that this may be None even if nparams is greater than zero. This is usually the case for special generic aliases like typing.List for which no explicit type variables are defined in the typing module.","title":"parameters"},{"location":"api/typeapi.model/#args","text":"The type arguments that the origin was parametrized with. This is None if the type is not explicitly parametrized. It may still contain typing.TypeVars if that is what the type was parametrized with.","title":"args"},{"location":"api/typeapi.model/#with_args","text":"def with_args ( args : t . Optional [ t . Tuple [ Hint , ... ]]) -> Type [view_source] Return a copy of the Type object, but args replaced by the args parameter value.","title":"with_args"},{"location":"api/typeapi.model/#get_parameter_mapping","text":"def get_parameter_mapping () -> t . Dict [ t . TypeVar , Hint ] [view_source] Computes the values assigned to all type parameters present in type and its bases.","title":"get_parameter_mapping"},{"location":"api/typeapi.model/#get_orig_bases","text":"def get_orig_bases ( all_ : bool = False ) -> t . Iterable [ utils . GenericAlias ] [view_source] A generator for the generic aliases that comprise the generic base classes of type . Note that if args is not None , it means this Type object was created from a generic alias, but that generic alias is not returned by this generator. Arguments : all_ - If set to True , all original bases in the entire class hierarchy will be returned.","title":"get_orig_bases"},{"location":"api/typeapi.model/#get_orig_bases_parametrized","text":"def get_orig_bases_parametrized ( all_ : bool = False ) -> t . Dict [ utils . GenericAlias , Type ] [view_source] Create a dictionary that maps the generic aliases returned by get_orig_bases() to a type hint infused with the current type's args . If the type is not a generic or has no generic bases, this method returns an empty dictionary. Note that this will skip typing.Generic .","title":"get_orig_bases_parametrized"},{"location":"api/typeapi.model/#of","text":"@staticmethod def of ( type_ : t . Any ) -> Type [view_source] Deconstruct a type hint that is concrete type or generic alias, i.e. one that is not a \"special form\" like typing.Union or typing.Any . Examples of types being accepted are any actual Python types, typing.Any , special generic aliases like typing.List (unspecialized) or generic aliases (like typing.List[int] or a parametrization of a typing.Generic subclass). Arguments : type_ any - The type hint to deconstruct. Raises : ValueError - If the type_ parameter cannot be deconstructed into a Type . For example, passing a typing.Annotated object or typing.ClassVar will cause this error to be raised.","title":"of"},{"location":"api/typeapi.model/#class-union","text":"@dataclasses . dataclass ( repr = False ) class Union ( Hint ) [view_source] Represents typing.Union or typing.Optional .","title":"Class Union"},{"location":"api/typeapi.model/#types","text":"The types in this union.","title":"types"},{"location":"api/typeapi.model/#has_none_type","text":"def has_none_type () -> bool [view_source] Returns True if one of the types is a Type representing types.NoneType .","title":"has_none_type"},{"location":"api/typeapi.model/#without_none_type","text":"def without_none_type () -> Hint [view_source] Return a copy but with types not containing a types.NoneType . If there is only one member remaining, that member type hint will be returned directly (because Union must contain at least two members).","title":"without_none_type"},{"location":"api/typeapi.model/#class-annotated","text":"@dataclasses . dataclass ( repr = False ) class Annotated ( Hint ) [view_source] Represents a type wrapped in typing.Annotated .","title":"Class Annotated"},{"location":"api/typeapi.model/#wrapped","text":"The type that is annotated.","title":"wrapped"},{"location":"api/typeapi.model/#metadata","text":"The metadata in the annotation.","title":"metadata"},{"location":"api/typeapi.model/#class-forwardref","text":"@dataclasses . dataclass ( repr = False ) class ForwardRef ( Hint ) [view_source] Represents a forward reference.","title":"Class ForwardRef"},{"location":"api/typeapi.model/#ref","text":"The forward reference.","title":"ref"},{"location":"api/typeapi.model/#expr","text":"@property def expr () -> str [view_source] Returns the code from the forward reference.","title":"expr"},{"location":"api/typeapi.model/#module","text":"@property def module () -> t . Optional [ str ] [view_source] Returns the name of the moduel in which the forward reference is to be evaluated.","title":"module"},{"location":"api/typeapi.model/#evaluate","text":"def evaluate ( fallback_module : t . Optional [ str ] = None , globalns : t . Optional [ t . Dict [ str , t . Any ]] = None , localns : t . Optional [ t . Dict [ str , t . Any ]] = None , recursive : bool = True ) -> t . Any [view_source] Evaluate the forward reference, preferably in the module that is already known by ref , or otherwise in the specified fallback_module or the specified globalns and localns namespaces..","title":"evaluate"},{"location":"api/typeapi.model/#class-any","text":"@dataclasses . dataclass ( repr = False ) class Any ( Hint ) [view_source] Represents typing.Any .","title":"Class Any"},{"location":"api/typeapi.model/#class-classvar","text":"@dataclasses . dataclass ( repr = False ) class ClassVar ( Hint ) [view_source] Represents typing.ClassVar .","title":"Class ClassVar"},{"location":"api/typeapi.model/#wrapped_1","text":"The inner type.","title":"wrapped"},{"location":"api/typeapi.model/#class-final","text":"@dataclasses . dataclass ( repr = False ) class Final ( Hint ) [view_source] Represents typing.Final .","title":"Class Final"},{"location":"api/typeapi.model/#wrapped_2","text":"The inner type.","title":"wrapped"},{"location":"api/typeapi.model/#class-noreturn","text":"@dataclasses . dataclass ( repr = False ) class NoReturn ( Hint ) [view_source] Represents typing.NoReturn .","title":"Class NoReturn"},{"location":"api/typeapi.model/#class-typeguard","text":"@dataclasses . dataclass ( repr = False ) class TypeGuard ( Hint ) [view_source] Represents typing.TypeGuard .","title":"Class TypeGuard"},{"location":"api/typeapi.model/#wrapped_3","text":"The wrapped type.","title":"wrapped"},{"location":"api/typeapi.model/#class-literal","text":"@dataclasses . dataclass ( repr = False ) class Literal ( Hint ) [view_source] Represents typing.Literal .","title":"Class Literal"},{"location":"api/typeapi.model/#values","text":"The possible values represented by the literal.","title":"values"},{"location":"api/typeapi.model/#class-typevar","text":"@dataclasses . dataclass ( repr = False ) class TypeVar ( Hint ) [view_source] Represents a typing.TypeVar .","title":"Class TypeVar"},{"location":"api/typeapi.model/#var","text":"The type variable.","title":"var"},{"location":"api/typeapi.model/#class-newtype","text":"@dataclasses . dataclass ( repr = False ) class NewType ( Hint ) [view_source] Represents typing.NewType .","title":"Class NewType"},{"location":"api/typeapi.model/#type_1","text":"The typing new type instance.","title":"type"},{"location":"api/typeapi.model/#name","text":"@property def name () -> str [view_source] The name of the new type.","title":"name"},{"location":"api/typeapi.model/#supertype","text":"@property def supertype () -> builtins . type [view_source] The underlying type of the new type.","title":"supertype"},{"location":"api/typeapi.model/#class-unknown","text":"@dataclasses . dataclass ( repr = False ) class Unknown ( Hint ) [view_source] Represents an type hint that is not understood.","title":"Class Unknown"},{"location":"api/typeapi.model/#hint","text":"The type hint that could not be converted into the typeapi.","title":"hint"},{"location":"api/typeapi.model/#eval_types","text":"def eval_types ( hint : Hint , module : t . Optional [ str ] = None , globalns : t . Optional [ t . Dict [ str , t . Any ]] = None , localns : t . Optional [ t . Dict [ str , t . Any ]] = None , ignore_name_errors : bool = False ) -> Hint [view_source] Evaluate all forward references present in hint . Arguments : hint - The typeapi Hint to evaluate forward references in. module - The name of the module to evaluate the references in if they are not already associated with a module. Note that the module must be present in sys.modules . globalns - A mapping to serve as a namespace to evaluate forward references in if module is not set and the forward reference has no module reference. localns - Same as globalns but for the local namespace. ignore_name_errors - Ignore NameError exceptions during evaluation and keep the type hint around as a ForwardRef . This is useful if you want to evaluate as much as possible of a type annotation, but don't care so much about resolving everything (e.g. if only the root type hint is of interest). Note the string annotation must in turn contain a string in order for the forward ref to be partiially resolvable (e.g. 'Property[\"Content\"]' ). Returns : The same hint with all forward references replaced.","title":"eval_types"},{"location":"api/typeapi.model/#infuse_type_parameters","text":"@t . overload def infuse_type_parameters ( hint : Type , parameters : t . Dict [ t . TypeVar , Hint ]) -> Type [view_source] If you already have a Type hint, infusing it returns just another Type .","title":"infuse_type_parameters"},{"location":"api/typeapi.model/#infuse_type_parameters_1","text":"@t . overload def infuse_type_parameters ( hint : Hint , parameters : t . Dict [ t . TypeVar , Hint ]) -> Hint [view_source] Replace type variables in hint with the parameters in the given mapping.","title":"infuse_type_parameters"},{"location":"api/typeapi.model/#unwrap","text":"def unwrap ( hint : Hint ) -> t . Tuple [ Hint , t . Tuple [ t . Any , ... ]] [view_source] If given a typing.Annotated hint, returns the wrapped hint and the annotation metadata. Otherwise, the hint is returned as-is and an empty tuple for metadata.","title":"unwrap"},{"location":"api/typeapi.parser/","text":"parse_type_hint @t . overload def parse_type_hint ( hint : t . Any ) -> Hint [view_source] Parse the given type hint to a Hint object. If the type hint is not accepted by any of the handlers, an instance of Unknown is returned instead. Arguments : hint - The type hint to adapt. Returns : A Hint object that should make it easier to introspect the type hint with a stable API. parse_type_hint @t . overload def parse_type_hint ( hint : t . Any , * , debug : te . Literal [ True ]) -> t . Tuple [ Hint , t . Optional [ str ]] [view_source] Same as parse_type_hint() , but returns the name of the handler function that accepted the type hint and converted it to a Hint object.","title":"typeapi.parser"},{"location":"api/typeapi.parser/#parse_type_hint","text":"@t . overload def parse_type_hint ( hint : t . Any ) -> Hint [view_source] Parse the given type hint to a Hint object. If the type hint is not accepted by any of the handlers, an instance of Unknown is returned instead. Arguments : hint - The type hint to adapt. Returns : A Hint object that should make it easier to introspect the type hint with a stable API.","title":"parse_type_hint"},{"location":"api/typeapi.parser/#parse_type_hint_1","text":"@t . overload def parse_type_hint ( hint : t . Any , * , debug : te . Literal [ True ]) -> t . Tuple [ Hint , t . Optional [ str ]] [view_source] Same as parse_type_hint() , but returns the name of the handler function that accepted the type hint and converted it to a Hint object.","title":"parse_type_hint"},{"location":"api/typeapi.utils/","text":"This module provides helper functions to introspect raw typing type hints. It is used mostly internally. You should use typeapi.of() and the datatypes defined in typeapi.models to introspect type hints. Class TypedDict class TypedDict ( te . Protocol ) [view_source] A protocol that describes typing.TypedDict values (which are actually instances of the typing._TypedDictMeta metaclass). Use is_typed_dict() to check if a hint is matches this protocol. is_generic def is_generic ( hint : t . Any ) -> te . TypeGuard [ t . Type [ Generic ]] [view_source] Returns : True if hint is a subclass of typing.Generic (and not an alias of it). !!! note This returns False for typing.Generic because it does not have a __parameters__ attribute. is_generic_alias def is_generic_alias ( hint : t . Any ) -> te . TypeGuard [ GenericAlias ] [view_source] Returns : True if hint is a typing._GenericAlias or types.GenericAlias ( PEP 585 since Python 3.10+). !!! note In Python versions 3.8 and older, typing._GenericAlias is used also for special generic aliases (see is_special_generic_alias() ). This function will return False for these types of aliases to clearly distinct between special aliases and normal aliases, even if they share the same type. is_union_type def is_union_type ( hint : t . Any ) -> te . TypeGuard [ UnionType ] [view_source] Returns : True if hint is a typing.Union or types.UnionType . is_special_generic_alias def is_special_generic_alias ( hint : t . Any ) -> te . TypeGuard [ SpecialGenericAlias ] [view_source] Returns : True if hint is a typing._SpecialGenericAlias (like typing.List or typing.Mapping ). !!! note For Python versions 3.8 and older, the function treats typing._GenericAliases as special if their _special attribute is set to True . typing._SpecialGenericAlias was introduced in Python 3.9. is_special_form def is_special_form ( hint : t . Any ) -> te . TypeGuard [ SpecialGenericAlias ] [view_source] Returns : True if hint is a typing._SpecialForm (like typing.Final or typing.Union ). is_annotated_alias def is_annotated_alias ( hint : t . Any ) -> te . TypeGuard [ AnnotatedAlias ] [view_source] Returns : True if hint is a typing._AnnotatedAlias (e.g. typing.Annotated[int, 42] ). is_new_type def is_new_type ( hint : t . Any ) -> te . TypeGuard [ NewType ] [view_source] Returns : True if hint is a typing.NewType object. is_typed_dict def is_typed_dict ( hint : t . Any ) -> te . TypeGuard [ TypedDict ] [view_source] Returns : True if hint is a typing.TypedDict . !!! note Typed dictionaries are actually just type objects. This means typeapi.of() will represent them as typeapi.models.Type . get_special_generic_aliases @functools . lru_cache () def get_special_generic_aliases () -> t . Dict [ str , SpecialGenericAlias ] [view_source] Returns a dictionary that contains all special generic aliases (like typing.List and typing.Mapping ) defined in the typing module. Example : import typing from typeapi.utils import get_special_generic_aliases mapping = get_special_generic_aliases () assert mapping [ 'List' ] is typing . List get_origins_to_special_generic_aliases @functools . lru_cache () def get_origins_to_special_generic_aliases ( ) -> t . Dict [ type , SpecialGenericAlias ] [view_source] Returns a dictionary that maps a native Python type to the typing special generic alias. Example : import typing from typeapi.utils import get_origins_to_special_generic_aliases mapping = get_origins_to_special_generic_aliases () assert mapping [ list ] is typing . List get_special_forms @functools . lru_cache () def get_special_forms () -> t . Dict [ str , SpecialGenericAlias ] [view_source] Returns a dictionary that contains all special forms (like typing.Final and typing.Union ) defined in the typing module. Example : import typing from typeapi.utils import get_special_forms mapping = get_special_forms () assert mapping [ 'Any' ] is typing . Any assert mapping [ 'Union' ] is typing . Union type_repr def type_repr ( obj : t . Any ) -> str [view_source] typing._type_repr() stolen from Python 3.8. get_annotations def get_annotations ( obj : t . Union [ t . Callable [ ... , t . Any ], types . ModuleType , type ], include_bases : bool = False , globalns : t . Optional [ t . Dict [ str , t . Any ]] = None , localns : t . Optional [ t . Dict [ str , t . Any ]] = None ) -> t . Dict [ str , t . Any ] [view_source] Like typing.get_type_hints() , but always includes extras. This is important when we want to inspect typing.Annotated hints (without extras the annotations are removed). In Python 3.10 and onwards, this is an alias for inspect.get_annotations() with eval_str=True . If include_bases is set to True , annotations from base classes are taken into account as well. This function will take into account the locals and globals accessible through the frame associated with a function or type by the scoped() decorator. scoped def scoped ( obj : T ) -> T [view_source] A decorator that associates the caller's frame with the object such that get_annotations() can use it as the scope to resolve forward references in. Example : import typeapi def get_ab (): class A : v : int @typeapi . scoped class B : a : 'A' return B A , B = get_ab () assert typeapi . get_annotations ( B ) == { 'a' : A } scope def scope ( obj : t . Union [ type , types . FunctionType ]) -> t . Optional [ t . Dict [ str , t . Any ]] [view_source] Retrieve the scope that was assigned to obj via the scoped() decorator.","title":"typeapi.utils"},{"location":"api/typeapi.utils/#class-typeddict","text":"class TypedDict ( te . Protocol ) [view_source] A protocol that describes typing.TypedDict values (which are actually instances of the typing._TypedDictMeta metaclass). Use is_typed_dict() to check if a hint is matches this protocol.","title":"Class TypedDict"},{"location":"api/typeapi.utils/#is_generic","text":"def is_generic ( hint : t . Any ) -> te . TypeGuard [ t . Type [ Generic ]] [view_source] Returns : True if hint is a subclass of typing.Generic (and not an alias of it). !!! note This returns False for typing.Generic because it does not have a __parameters__ attribute.","title":"is_generic"},{"location":"api/typeapi.utils/#is_generic_alias","text":"def is_generic_alias ( hint : t . Any ) -> te . TypeGuard [ GenericAlias ] [view_source] Returns : True if hint is a typing._GenericAlias or types.GenericAlias ( PEP 585 since Python 3.10+). !!! note In Python versions 3.8 and older, typing._GenericAlias is used also for special generic aliases (see is_special_generic_alias() ). This function will return False for these types of aliases to clearly distinct between special aliases and normal aliases, even if they share the same type.","title":"is_generic_alias"},{"location":"api/typeapi.utils/#is_union_type","text":"def is_union_type ( hint : t . Any ) -> te . TypeGuard [ UnionType ] [view_source] Returns : True if hint is a typing.Union or types.UnionType .","title":"is_union_type"},{"location":"api/typeapi.utils/#is_special_generic_alias","text":"def is_special_generic_alias ( hint : t . Any ) -> te . TypeGuard [ SpecialGenericAlias ] [view_source] Returns : True if hint is a typing._SpecialGenericAlias (like typing.List or typing.Mapping ). !!! note For Python versions 3.8 and older, the function treats typing._GenericAliases as special if their _special attribute is set to True . typing._SpecialGenericAlias was introduced in Python 3.9.","title":"is_special_generic_alias"},{"location":"api/typeapi.utils/#is_special_form","text":"def is_special_form ( hint : t . Any ) -> te . TypeGuard [ SpecialGenericAlias ] [view_source] Returns : True if hint is a typing._SpecialForm (like typing.Final or typing.Union ).","title":"is_special_form"},{"location":"api/typeapi.utils/#is_annotated_alias","text":"def is_annotated_alias ( hint : t . Any ) -> te . TypeGuard [ AnnotatedAlias ] [view_source] Returns : True if hint is a typing._AnnotatedAlias (e.g. typing.Annotated[int, 42] ).","title":"is_annotated_alias"},{"location":"api/typeapi.utils/#is_new_type","text":"def is_new_type ( hint : t . Any ) -> te . TypeGuard [ NewType ] [view_source] Returns : True if hint is a typing.NewType object.","title":"is_new_type"},{"location":"api/typeapi.utils/#is_typed_dict","text":"def is_typed_dict ( hint : t . Any ) -> te . TypeGuard [ TypedDict ] [view_source] Returns : True if hint is a typing.TypedDict . !!! note Typed dictionaries are actually just type objects. This means typeapi.of() will represent them as typeapi.models.Type .","title":"is_typed_dict"},{"location":"api/typeapi.utils/#get_special_generic_aliases","text":"@functools . lru_cache () def get_special_generic_aliases () -> t . Dict [ str , SpecialGenericAlias ] [view_source] Returns a dictionary that contains all special generic aliases (like typing.List and typing.Mapping ) defined in the typing module. Example : import typing from typeapi.utils import get_special_generic_aliases mapping = get_special_generic_aliases () assert mapping [ 'List' ] is typing . List","title":"get_special_generic_aliases"},{"location":"api/typeapi.utils/#get_origins_to_special_generic_aliases","text":"@functools . lru_cache () def get_origins_to_special_generic_aliases ( ) -> t . Dict [ type , SpecialGenericAlias ] [view_source] Returns a dictionary that maps a native Python type to the typing special generic alias. Example : import typing from typeapi.utils import get_origins_to_special_generic_aliases mapping = get_origins_to_special_generic_aliases () assert mapping [ list ] is typing . List","title":"get_origins_to_special_generic_aliases"},{"location":"api/typeapi.utils/#get_special_forms","text":"@functools . lru_cache () def get_special_forms () -> t . Dict [ str , SpecialGenericAlias ] [view_source] Returns a dictionary that contains all special forms (like typing.Final and typing.Union ) defined in the typing module. Example : import typing from typeapi.utils import get_special_forms mapping = get_special_forms () assert mapping [ 'Any' ] is typing . Any assert mapping [ 'Union' ] is typing . Union","title":"get_special_forms"},{"location":"api/typeapi.utils/#type_repr","text":"def type_repr ( obj : t . Any ) -> str [view_source] typing._type_repr() stolen from Python 3.8.","title":"type_repr"},{"location":"api/typeapi.utils/#get_annotations","text":"def get_annotations ( obj : t . Union [ t . Callable [ ... , t . Any ], types . ModuleType , type ], include_bases : bool = False , globalns : t . Optional [ t . Dict [ str , t . Any ]] = None , localns : t . Optional [ t . Dict [ str , t . Any ]] = None ) -> t . Dict [ str , t . Any ] [view_source] Like typing.get_type_hints() , but always includes extras. This is important when we want to inspect typing.Annotated hints (without extras the annotations are removed). In Python 3.10 and onwards, this is an alias for inspect.get_annotations() with eval_str=True . If include_bases is set to True , annotations from base classes are taken into account as well. This function will take into account the locals and globals accessible through the frame associated with a function or type by the scoped() decorator.","title":"get_annotations"},{"location":"api/typeapi.utils/#scoped","text":"def scoped ( obj : T ) -> T [view_source] A decorator that associates the caller's frame with the object such that get_annotations() can use it as the scope to resolve forward references in. Example : import typeapi def get_ab (): class A : v : int @typeapi . scoped class B : a : 'A' return B A , B = get_ab () assert typeapi . get_annotations ( B ) == { 'a' : A }","title":"scoped"},{"location":"api/typeapi.utils/#scope","text":"def scope ( obj : t . Union [ type , types . FunctionType ]) -> t . Optional [ t . Dict [ str , t . Any ]] [view_source] Retrieve the scope that was assigned to obj via the scoped() decorator.","title":"scope"}]}