{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"python-typeapi <p>The <code>typeapi</code> package provides a unified and consistent API for the reflection and introspection of Python type hints. In addition, it allows evaluating future annotations such as PEP585 (such as <code>list[str]</code>) and PEP604 (such as <code>int | str</code>) in in versions that don't natively support them.</p> <p>Requirements:</p> <ul> <li>Python 3.8 or newer</li> </ul> <p>Please file bug reports and feature requests on GitHub.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":"TypeDescriptionPRIssuesAuthor Fix  Fixed an error when evaluating `FakeHint` objects when an argument to a type-hint such as `Annotated` was the constant value `True`, `False`, `None`, `0` or `1`.@NiklasRosenstein"},{"location":"changelog/#211-2023-07-10","title":"2.1.1 (2023-07-10)","text":"TypeDescriptionPRIssuesAuthor Fix  Fix `ClassVarTypeHint._copy_with_args()`@NiklasRosenstein"},{"location":"changelog/#210-2023-07-03","title":"2.1.0 (2023-07-03)","text":"TypeDescriptionPRIssuesAuthor Feature  Support `TypeAlias` and `ClassVar` type hints@NiklasRosenstein"},{"location":"changelog/#201-2023-06-21","title":"2.0.1 (2023-06-21)","text":"TypeDescriptionPRIssuesAuthor Fix  `ClassTypeHint.recurse_bases()` now parameterizes type parameters.@NiklasRosenstein"},{"location":"changelog/#200-2023-06-12","title":"2.0.0 (2023-06-12)","text":"TypeDescriptionPRIssuesAuthor Breaking change  A plain `tuple` type is no longer represented by a `TupleTypeHint`, but instead by a `ClassTypeHint`.@NiklasRosenstein"},{"location":"changelog/#151-2023-06-11","title":"1.5.1 (2023-06-11)","text":"TypeDescriptionPRIssuesAuthor Fix  `ClassTypeHint.bases` now falls back to the types actual base classes if it is not a generic type@NiklasRosenstein Feature  add `ClassTypeHint.recurse_bases()`@NiklasRosenstein"},{"location":"changelog/#150-2023-06-11","title":"1.5.0 (2023-06-11)","text":"TypeDescriptionPRIssuesAuthor Improvement  `TupleTypeHint` is now a subclass of `ClassTypeHint`; `ClassTypeHint.bases` no longer returns none@NiklasRosenstein"},{"location":"changelog/#143-2023-05-13","title":"1.4.3 (2023-05-13)","text":"TypeDescriptionPRIssuesAuthor Improvement  Add `TupleTypeHint.type`@NiklasRosenstein"},{"location":"changelog/#142-2023-04-12","title":"1.4.2 (2023-04-12)","text":"TypeDescriptionPRIssuesAuthor Fix  Fixed evaluating forward references to members on the class level. Note that the `TypeHint(source)` parameter must be set accordingly to the class where the forward reference should be resolved in.@NiklasRosenstein"},{"location":"changelog/#141-2023-03-23","title":"1.4.1 (2023-03-23)","text":"TypeDescriptionPRIssuesAuthor Docs  Clarify that future type hint evaluation for Union-style syntax continues to return a `typing.Union` instead of `types.UnionType` even in Python 3.10+.@NiklasRosenstein Fix  Fix taking into account an objects origin module for the global namespace when resolving forward references.@NiklasRosenstein"},{"location":"changelog/#140-2023-03-02","title":"1.4.0 (2023-03-02)","text":"TypeDescriptionPRIssuesAuthor Fix  provide experimental support for evaluating future type hints that perform a function call; sometimes this is used in the metadata for `Anntoated[...]` hints@NiklasRosenstein Fix  Support evaluation of future type hints in `typeapi.get_annotations()` and add new `typeapi.get_annotations(eval_str)` parameter. We backport a modified version of `inspect.get_annotations()` from Python 3.11 for this.@NiklasRosenstein"},{"location":"changelog/#135-2023-01-10","title":"1.3.5 (2023-01-10)","text":"TypeDescriptionPRIssuesAuthor Fix  fix type hint fake evaluation when an actual typing.Optional is encountered@NiklasRosenstein"},{"location":"changelog/#134-2022-12-10","title":"1.3.4 (2022-12-10)","text":"TypeDescriptionPRIssuesAuthor Fix  fix passing `TypeHint(source)` argument which before would not be accepted@NiklasRosenstein"},{"location":"changelog/#133-2022-12-05","title":"1.3.3 (2022-12-05)","text":"TypeDescriptionPRIssuesAuthor Feature  add `TypeHint.source`, `TypeHint.get_context()` and make `TypeHint.evaluate(context)` argument optional@NiklasRosenstein Fix  Support `types.UnionType` in Python 3.10+7@NiklasRosenstein"},{"location":"changelog/#132-2022-11-11","title":"1.3.2 (2022-11-11)","text":"TypeDescriptionPRIssuesAuthor Fix  fix evaluating type hints that are attributes of other objects (`FakeHint` did not implement `__getattr__()`)@NiklasRosenstein"},{"location":"changelog/#131-2022-11-11","title":"1.3.1 (2022-11-11)","text":"TypeDescriptionPRIssuesAuthor Fix  fix evaluation of PEP604 optional type hints (e.g. `int | None`)@NiklasRosenstein"},{"location":"changelog/#130-2022-11-11","title":"1.3.0 (2022-11-11)","text":"TypeDescriptionPRIssuesAuthor Feature  support future typing syntax (such as `list[int]` and `int | None`) when evaluating forward references.5@NiklasRosenstein"},{"location":"changelog/#121-2022-11-10","title":"1.2.1 (2022-11-10)","text":"TypeDescriptionPRIssuesAuthor Fix  expose TupleTypeHint@NiklasRosenstein"},{"location":"changelog/#120-2022-11-10","title":"1.2.0 (2022-11-10)","text":"TypeDescriptionPRIssuesAuthor Feature  add `TupleTypeHint` support@NiklasRosenstein"},{"location":"changelog/#110-2022-11-10","title":"1.1.0 (2022-11-10)","text":"TypeDescriptionPRIssuesAuthor Improvement  support all common special generic aliases instead of just List and Dict when using TypeHint.parameterize() or TypeHint.evaluate()@NiklasRosenstein Fix  Mark typeapi as requiring at least Python 3.6.3 or higher, this is because Forward references on class members are not correctly resolved by typing.get_type_hints() in 3.6.2 and before (see https://github.com/python/cpython/commit/1658ec07577ef9696cea76fcf7fac2da18403ec5#diff-ddb987fca5f5df0c9a2f5521ed687919d70bb3d64eaeb8021f98833a2a716887R1501-R1504)@NiklasRosenstein Improvement  Improve error message when `TypeHint._copy_with_args()` fails due to a TypeError (eg if the type is not actually subscriptable) to include the type in question.@NiklasRosenstein"},{"location":"changelog/#101-2022-11-06","title":"1.0.1 (2022-11-06)","text":"TypeDescriptionPRIssuesAuthor Fix  add `TypeHint.__iter__()`@NiklasRosenstein"},{"location":"changelog/#100-2022-11-06","title":"1.0.0 (2022-11-06)","text":"TypeDescriptionPRIssuesAuthor Breaking change  Full rewrite of `typeapi` with limited support for more exotic type hints but strong support for common runtime type hint needs.@NiklasRosenstein"},{"location":"changelog/#022-2022-08-30","title":"0.2.2 (2022-08-30)","text":"TypeDescriptionPRIssuesAuthor Fix  fix issue with `typeapi.get_annotations(include_bases=False)` if class has no explicit annotations3@NiklasRosenstein"},{"location":"changelog/#021-2022-06-20","title":"0.2.1 (2022-06-20)","text":"TypeDescriptionPRIssuesAuthor Improvement  Enable strict type checking in Mypy@NiklasRosenstein"},{"location":"changelog/#020-2022-05-29","title":"0.2.0 (2022-05-29)","text":"TypeDescriptionPRIssuesAuthor Improvement  Limit types accepted for `typeapi.get_annotations() to modules, types and callables as is also the case in `inspect.get_annotations()` starting with 3.10@NiklasRosenstein"},{"location":"changelog/#016-2022-04-19","title":"0.1.6 (2022-04-19)","text":"TypeDescriptionPRIssuesAuthor Feature  Add `recursive` argument to `ForwardRef.evaluate()`@NiklasRosenstein Feature  Add `ignore_name_errors` to `eval_types()`@NiklasRosenstein"},{"location":"changelog/#015-2022-03-23","title":"0.1.5 (2022-03-23)","text":"TypeDescriptionPRIssuesAuthor Feature  add `typeapi.utils.scope()`@NiklasRosenstein"},{"location":"changelog/#014-2022-03-23","title":"0.1.4 (2022-03-23)","text":"TypeDescriptionPRIssuesAuthor Feature  add `typeapi.utils.unwrap()`@NiklasRosenstein"},{"location":"changelog/#013-2022-03-23","title":"0.1.3 (2022-03-23)","text":"TypeDescriptionPRIssuesAuthor Feature  add `globalns` and `localns` parameters to `get_annotations()` and `ForwardRef.evaluate()`@NiklasRosenstein Feature  add `typeapi.utils.scoped()` decorator@NiklasRosenstein"},{"location":"changelog/#012-2022-03-22","title":"0.1.2 (2022-03-22)","text":"TypeDescriptionPRIssuesAuthor Improvement  add `get_annotations(include_bases)` parameter@NiklasRosenstein Improvement  update `ForweardRef.__repr__()`@NiklasRosenstein"},{"location":"changelog/#011-2022-03-17","title":"0.1.1 (2022-03-17)","text":"TypeDescriptionPRIssuesAuthor Fix  Fix an error caused when using `Type.get_orig_bases()` if the `Type.type` has non-generic bases@NiklasRosenstein Deprecation  Deprecated `get_type_hints()` in favor of new `get_annotations()`@NiklasRosenstein Fix  Fix `get_annotations()` in Python 3.9 and older to have the same behaviour as `inspect.get_annotations()` in that it does not include annotations of a classes' bases@NiklasRosenstein Feature  Add `typeapi.utils.is_typed_dict()` and the `typeapi.utils.TypedDict` protocol@NiklasRosenstein"},{"location":"changelog/#010-2022-03-17","title":"0.1.0 (2022-03-17)","text":"TypeDescriptionPRIssuesAuthor Feature  Add `Type.get_orig_bases()`@NiklasRosenstein Feature  Add `Type.get_orig_bases_parametrized()`@NiklasRosenstein Fix  Fix `infuse_type_parameters()` to replace sole `typeapi.TypeVar` instead of only occurrences in `typeapi.Type.args`@NiklasRosenstein Fix  Fix `infuse_type_parameters()` to replace sole `typeapi.TypeVar` instead of only occurrences in `typeapi.Type.args`@NiklasRosenstein Fix  Fix `Type.get_parameter_mapping()` return annotation@NiklasRosenstein Fix  Fix `infuse_type_parameters()` to handle plain `typeapi.TypeVar` and not just the like in `typeapi.Type.args`@NiklasRosenstein"},{"location":"changelog/#010a5-2022-03-17","title":"0.1.0a5 (2022-03-17)","text":"TypeDescriptionPRIssuesAuthor Breaking change  Change `ForwardRef` and `NewType` to hold the origin `typing` object@NiklasRosenstein Feature  Implement `ForwardRef.evaluate()`@NiklasRosenstein Feature  add `typeapi.eval_types()`@NiklasRosenstein Feature  add `typeapi.infuse_type_parameters()`@NiklasRosenstein"},{"location":"changelog/#010a4-2022-03-17","title":"0.1.0a4 (2022-03-17)","text":"TypeDescriptionPRIssuesAuthor Fix  fix `from typeapi import *`@NiklasRosenstein Improvement  export `get_type_hints()` and `type_repr()` in `typeapi` root module@NiklasRosenstein Improvement  `is_generic()` no longer returns true if the type is the actualy `typing.Generic` because only its subclasses of `__parameters__`@NiklasRosenstein Fix  `Type.of()` no longer errors on passing `typing.Generic` and handles it as `Type(typing.Generic, 0, None, None)`@NiklasRosenstein Feature  Add `Type.get_parameter_mapping()`@NiklasRosenstein Breaking change  Type hints are now converted recursively, all recursive API models now store `Hint` objects directly instead of the raw typing argument.@NiklasRosenstein"},{"location":"changelog/#010a3-2022-03-15","title":"0.1.0a3 (2022-03-15)","text":"TypeDescriptionPRIssuesAuthor Breaking change  remove `Type.args` field and instead make it a property@NiklasRosenstein Breaking change  Added `Type.info` property@NiklasRosenstein Feature  `deconstruct_type()` now supports concrete types@NiklasRosenstein Feature  export members from `typeapi.api`, `typeapi.parser` and `typeapi.deconstruct`, most notably `typeapi.of()` is not available as an alias for `typeapi.parser.parse_type_hint()`@NiklasRosenstein Breaking change  remove `Hint.source`@NiklasRosenstein Breaking change  remove `typeapi.deconstruct` module, make `typeapi.model.Type` have the fields that `TypeInfo` used to have and move `deconstruct_type()` to `Type.of()`@NiklasRosenstein"},{"location":"changelog/#010a2-2022-03-15","title":"0.1.0a2 (2022-03-15)","text":"TypeDescriptionPRIssuesAuthor Breaking change  add `Hint.source` field@NiklasRosenstein"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#inspect-a-listint-type-hint","title":"Inspect a <code>List[int]</code> type hint","text":"<pre><code>from typeapi import ClassTypeHint, TypeHint\nfrom typing import List\n\nhint = TypeHint(List[int])\nassert isinstance(hint, ClassTypeHint)\nassert hint.type is list\n\nitem_hint = hint[0]\nassert isinstance(item_hint, ClassTypeHint)\nassert item_hint.type is int\n</code></pre>"},{"location":"examples/#retrieve-the-metadata-from-an-annotated-type-hint","title":"Retrieve the metadata from an <code>Annotated[...]</code> type hint","text":"<pre><code>from typeapi import AnnotatedTypeHint, ClassTypeHint, TypeHint\nfrom typing_extensions import Annotated\n\nhint = TypeHint(Annotated[int, 42])\nassert isinstance(hint, AnnotatedTypeHint)\nassert hint.type is int\nassert hint.metadata == (42,)\n\nsub_hint = hint[0]\nassert isinstance(sub_hint, ClassTypeHint)\nassert sub_hint.type is int\n</code></pre>"},{"location":"examples/#parameterize-one-type-hint-with-the-parameterization-of-a-generic-alias","title":"Parameterize one type hint with the parameterization of a generic alias","text":"<pre><code>from dataclasses import dataclass\nfrom typeapi import ClassTypeHint, TypeHint\nfrom typing import Generic, TypeVar\nfrom typing_extensions import Annotated\n\nT = TypeVar(\"T\")\n\n@dataclass\nclass MyGeneric(Generic[T]):\n  value: T\n\nhint = TypeHint(MyGeneric[int])\nassert isinstance(hint, ClassTypeHint)\nassert hint.get_parameter_map() == {T: int}\n\nmember_hint = TypeHint(T).parameterize(hint.get_parameter_map())\nassert isinstance(member_hint, ClassTypeHint)\nassert member_hint.type is int\n</code></pre>"},{"location":"examples/#evaluate-forward-references-with-get_annotations","title":"Evaluate forward references with <code>get_annotations()</code>","text":"<pre><code>from typeapi import get_annotations\nfrom typing import Optional\nfrom sys import version_info\n\nclass MyType:\n  a: \"str | None\"\n\nannotations = get_annotations(MyType)\n\nif version_info[:2] &lt; (3, 10):\n  assert annotations == {\"a\": Optional[str]}\nelse:\n  assert annotations == {\"a\": str | None}\n</code></pre>"},{"location":"examples/#evaluating-forward-references-with-the-typehint-api","title":"Evaluating forward references with the <code>TypeHint</code> API","text":"<pre><code>from typeapi import ClassTypeHint, ForwardRefTypeHint, TypeHint\n\nMyVector = \"list[MyType]\"\n\nclass MyType:\n  pass\n\nhint = TypeHint(MyVector).evaluate(globals())\nprint(hint)  # TypeHint(typing.List[__main__.MyType])\nassert isinstance(hint, ClassTypeHint)\nassert hint.type is list\n\nitem_hint = hint[0]\nassert isinstance(item_hint, ClassTypeHint)\nassert item_hint.type is MyType\n</code></pre>"},{"location":"features/","title":"Supported Features","text":"<p>This page documents all features of the Python type annotation ecosystem that are supported by the <code>typeapi</code> package.</p> Feature Supported since Example Implemented via Related PEPs Normal type hint 1.0.0 <code>int</code>, <code>MyType</code>, <code>list[str]</code> <code>ClassTypeHint</code> PEP484, PEP526 Generics in standard collection [^4] 1.3.0 <code>list[int]</code>, <code>dict[str, str]</code> <code>ClassTypeHint</code> PEP585 Tuples 1.0.0 <code>tuple[int, str]</code>, <code>Tuple[Any, ...]</code> <code>TupleTypeHint</code> PEP484 Union types 1.0.0 <code>Union[int, str]</code>, <code>int \\| str</code> <code>UnionTypeHint</code> PEP484, PEP604 Sugar syntax for union types [^5] 1.3.0 <code>int \\| str</code> <code>UnionTypeHint</code> PEP604 Literals 1.0.0 <code>Literal[\"a\", 42]</code> <code>LiteralTypeHint</code> PEP586 Annotated 1.0.0 <code>Annotated[int, \"hello_world\"]</code> <code>AnnotatedTypeHint</code> PEP484, PEP593 Type variables 1.0.0 <code>TypeVar(\"T\")</code> <code>TypeVarTypeHint</code> PEP484, PEP646 [^2], PEP695 [^3] Forward references 1.0.0 <code>\"MyType\"</code> <code>ForwardRefTypeHint</code> PEP484 <p>[^2]: PEP646 - Variadic Generics is not currently officially supported. Reflecting type hints using this language feature may fail.</p> <p>[^3]: PEP695 - Type Parameter Syntax is not currently officially supported. Reflecting type hints using this language feature may fail.</p> <p>[^4]: Forward references may use the generic syntax introduced in PEP585 - Type Hinting Generics In Standard Collections in older Python (&lt; 3.9) versions that do not implement this PEP. <code>typeapi</code> will evaluate the forward reference accordingly and return the correct parameterized generic type hint from the <code>typing</code> module.</p> <p>[^5]: The union syntax introduced by PEP 604 - Allow writing union types as <code>X | Y</code> may be used in older Python versions (&lt; 3.10) via forward references. <code>typeapi</code> will evaluate the forward reference accordingly and return the corresponding <code>typing.Union</code> type hint. Note that the evaluation of new-style union types from string literals will always return a <code>typing.Union</code> despite the same syntax evaluated in Python versions supporting the syntax returning <code>types.UnionType</code> instead.</p>"},{"location":"api/typeapi/","title":"typeapi","text":""},{"location":"api/typeapi/#typeapi","title":"typeapi","text":""},{"location":"api/typeapi/#typeapi.AnnotatedTypeHint","title":"AnnotatedTypeHint","text":"<p>             Bases: <code>TypeHint</code></p> <p>Represents the <code>Annotated</code> type hint.</p> Source code in <code>typeapi/typehint.py</code> <pre><code>class AnnotatedTypeHint(TypeHint):\n    \"\"\"Represents the `Annotated` type hint.\"\"\"\n\n    @property\n    def args(self) -&gt; Tuple[Any, ...]:\n        return (self._args[0],)\n\n    def _copy_with_args(self, args: \"Tuple[Any, ...]\") -&gt; \"TypeHint\":\n        assert len(args) == 1\n        new_hint = Annotated[args + (self._args[1:])]  # type: ignore\n        return AnnotatedTypeHint(new_hint)\n\n    def __len__(self) -&gt; int:\n        return 1\n\n    @property\n    def type(self) -&gt; Any:\n        \"\"\"\n        Returns the wrapped type of the annotation. It's common to wrap the result in a `TypeHint` to recursively\n        introspect the wrapped type.\n\n            &gt;&gt;&gt; TypeHint(Annotated[int, \"foobar\"]).type\n            &lt;class 'int'&gt;\n        \"\"\"\n\n        return self._args[0]\n\n    @property\n    def metadata(self) -&gt; Tuple[Any, ...]:\n        \"\"\"\n        Returns the metadata, i.e. all the parameters after the wrapped type.\n\n            &gt;&gt;&gt; TypeHint(Annotated[int, \"foobar\"]).metadata\n            ('foobar',)\n        \"\"\"\n\n        return self._args[1:]\n</code></pre>"},{"location":"api/typeapi/#typeapi.AnnotatedTypeHint.metadata","title":"metadata  <code>property</code>","text":"<pre><code>metadata: Tuple[Any, ...]\n</code></pre> <p>Returns the metadata, i.e. all the parameters after the wrapped type.</p> <pre><code>&gt;&gt;&gt; TypeHint(Annotated[int, \"foobar\"]).metadata\n('foobar',)\n</code></pre>"},{"location":"api/typeapi/#typeapi.AnnotatedTypeHint.type","title":"type  <code>property</code>","text":"<pre><code>type: Any\n</code></pre> <p>Returns the wrapped type of the annotation. It's common to wrap the result in a <code>TypeHint</code> to recursively introspect the wrapped type.</p> <pre><code>&gt;&gt;&gt; TypeHint(Annotated[int, \"foobar\"]).type\n&lt;class 'int'&gt;\n</code></pre>"},{"location":"api/typeapi/#typeapi.ClassTypeHint","title":"ClassTypeHint","text":"<p>             Bases: <code>TypeHint</code></p> <p>Represents a real, possibly parameterized, type. For example <code>int</code>, <code>list</code>, <code>list[int]</code> or <code>list[T]</code>.</p> Source code in <code>typeapi/typehint.py</code> <pre><code>class ClassTypeHint(TypeHint):\n    \"\"\"Represents a real, possibly parameterized, type. For example `int`, `list`, `list[int]` or `list[T]`.\"\"\"\n\n    def __init__(self, hint: object, source: \"Any | None\" = None) -&gt; None:\n        super().__init__(hint, source)\n        assert isinstance(self.hint, type) or isinstance(self.origin, type), (\n            \"ClassTypeHint must be initialized from a real type or a generic that points to a real type. \"\n            f'Got \"{self.hint!r}\" with origin \"{self.origin}\"'\n        )\n\n    def parameterize(self, parameter_map: Mapping[object, Any]) -&gt; \"TypeHint\":\n        if self.type is Generic:  # type: ignore[comparison-overlap]\n            return self\n        return super().parameterize(parameter_map)\n\n    @property\n    def type(self) -&gt; type:\n        \"\"\"Returns the concrepte type.\"\"\"\n\n        if isinstance(self.origin, type):\n            return self.origin\n        if isinstance(self.hint, type):\n            return self.hint\n        assert False, \"ClassTypeHint not initialized from a real type or a generic that points to a real type.\"\n\n    @property\n    def bases(self) -&gt; \"Tuple[Any, ...]\":\n        \"\"\"\n        Return the bases of the classes' types. If the type is a generic, the bases of the generic's origin are\n        returned in their parameterized form (e.g. `Generic[T]` instead of `Generic` is returned).\n        \"\"\"\n\n        return get_type_hint_original_bases(self.type) or self.type.__bases__\n\n    def get_parameter_map(self) -&gt; Dict[Any, Any]:\n        \"\"\"\n        Returns a dictionary that maps generic parameters to their values.\n\n            &gt;&gt;&gt; TypeHint(List[int]).type\n            &lt;class 'list'&gt;\n            &gt;&gt;&gt; TypeHint(List[int]).args\n            (&lt;class 'int'&gt;,)\n\n            # NOTE(@niklas): This is a bug for built-in types, but it's not that big of a deal because we don't\n            #       usually need to recursively expand forward references in these types.\n            &gt;&gt;&gt; TypeHint(List[int]).parameters\n            ()\n            &gt;&gt;&gt; TypeHint(List[int]).get_parameter_map()\n            {}\n\n            &gt;&gt;&gt; T = TypeVar(\"T\")\n            &gt;&gt;&gt; class A(Generic[T]): pass\n            &gt;&gt;&gt; TypeHint(A[int]).get_parameter_map()\n            {~T: &lt;class 'int'&gt;}\n        \"\"\"\n\n        if not self.args:\n            return {}\n        # We need to look at the parameters of the original, un-parameterized type. That's why we can't\n        # use self.parameters.\n        return dict(zip(TypeHint(self.type).parameters, self.args))\n\n    def recurse_bases(\n        self, order: Literal[\"dfs\", \"bfs\"] = \"bfs\"\n    ) -&gt; Generator[\"ClassTypeHint\", Union[Literal[\"skip\"], None], None]:\n        \"\"\"\n        Iterate over all base classes of this type hint, and continues recursively. The iteration order is\n        determined by the *order* parameter, which can be either depth-first or breadh-first. If the generator\n        receives the string `\"skip\"` from the caller, it will skip the bases of the last yielded type.\n        \"\"\"\n\n        # Find the item type in the base classes of the collection type.\n        bases = deque([self])\n\n        while bases:\n            current = bases.popleft()\n            if not isinstance(current, ClassTypeHint):\n                raise RuntimeError(\n                    f\"Expected to find a ClassTypeHint in the base classes of {self!r}, found {current!r} instead.\"\n                )\n\n            response = yield current\n            if response == \"skip\":\n                continue\n\n            current_bases = cast(\n                List[ClassTypeHint],\n                [TypeHint(x, current.type).evaluate().parameterize(current.get_parameter_map()) for x in current.bases],\n            )\n\n            if order == \"bfs\":\n                bases.extend(current_bases)\n            elif order == \"dfs\":\n                bases.extendleft(reversed(current_bases))\n            else:\n                raise ValueError(f\"Invalid order {order!r}\")\n</code></pre>"},{"location":"api/typeapi/#typeapi.ClassTypeHint.bases","title":"bases  <code>property</code>","text":"<pre><code>bases: Tuple[Any, ...]\n</code></pre> <p>Return the bases of the classes' types. If the type is a generic, the bases of the generic's origin are returned in their parameterized form (e.g. <code>Generic[T]</code> instead of <code>Generic</code> is returned).</p>"},{"location":"api/typeapi/#typeapi.ClassTypeHint.type","title":"type  <code>property</code>","text":"<pre><code>type: type\n</code></pre> <p>Returns the concrepte type.</p>"},{"location":"api/typeapi/#typeapi.ClassTypeHint.get_parameter_map","title":"get_parameter_map","text":"<pre><code>get_parameter_map() -&gt; Dict[Any, Any]\n</code></pre> <p>Returns a dictionary that maps generic parameters to their values.</p> <pre><code>&gt;&gt;&gt; TypeHint(List[int]).type\n&lt;class 'list'&gt;\n&gt;&gt;&gt; TypeHint(List[int]).args\n(&lt;class 'int'&gt;,)\n\n# NOTE(@niklas): This is a bug for built-in types, but it's not that big of a deal because we don't\n#       usually need to recursively expand forward references in these types.\n&gt;&gt;&gt; TypeHint(List[int]).parameters\n()\n&gt;&gt;&gt; TypeHint(List[int]).get_parameter_map()\n{}\n\n&gt;&gt;&gt; T = TypeVar(\"T\")\n&gt;&gt;&gt; class A(Generic[T]): pass\n&gt;&gt;&gt; TypeHint(A[int]).get_parameter_map()\n{~T: &lt;class 'int'&gt;}\n</code></pre> Source code in <code>typeapi/typehint.py</code> <pre><code>def get_parameter_map(self) -&gt; Dict[Any, Any]:\n    \"\"\"\n    Returns a dictionary that maps generic parameters to their values.\n\n        &gt;&gt;&gt; TypeHint(List[int]).type\n        &lt;class 'list'&gt;\n        &gt;&gt;&gt; TypeHint(List[int]).args\n        (&lt;class 'int'&gt;,)\n\n        # NOTE(@niklas): This is a bug for built-in types, but it's not that big of a deal because we don't\n        #       usually need to recursively expand forward references in these types.\n        &gt;&gt;&gt; TypeHint(List[int]).parameters\n        ()\n        &gt;&gt;&gt; TypeHint(List[int]).get_parameter_map()\n        {}\n\n        &gt;&gt;&gt; T = TypeVar(\"T\")\n        &gt;&gt;&gt; class A(Generic[T]): pass\n        &gt;&gt;&gt; TypeHint(A[int]).get_parameter_map()\n        {~T: &lt;class 'int'&gt;}\n    \"\"\"\n\n    if not self.args:\n        return {}\n    # We need to look at the parameters of the original, un-parameterized type. That's why we can't\n    # use self.parameters.\n    return dict(zip(TypeHint(self.type).parameters, self.args))\n</code></pre>"},{"location":"api/typeapi/#typeapi.ClassTypeHint.recurse_bases","title":"recurse_bases","text":"<pre><code>recurse_bases(order: Literal['dfs', 'bfs'] = 'bfs') -&gt; Generator[ClassTypeHint, Union[Literal['skip'], None], None]\n</code></pre> <p>Iterate over all base classes of this type hint, and continues recursively. The iteration order is determined by the order parameter, which can be either depth-first or breadh-first. If the generator receives the string <code>\"skip\"</code> from the caller, it will skip the bases of the last yielded type.</p> Source code in <code>typeapi/typehint.py</code> <pre><code>def recurse_bases(\n    self, order: Literal[\"dfs\", \"bfs\"] = \"bfs\"\n) -&gt; Generator[\"ClassTypeHint\", Union[Literal[\"skip\"], None], None]:\n    \"\"\"\n    Iterate over all base classes of this type hint, and continues recursively. The iteration order is\n    determined by the *order* parameter, which can be either depth-first or breadh-first. If the generator\n    receives the string `\"skip\"` from the caller, it will skip the bases of the last yielded type.\n    \"\"\"\n\n    # Find the item type in the base classes of the collection type.\n    bases = deque([self])\n\n    while bases:\n        current = bases.popleft()\n        if not isinstance(current, ClassTypeHint):\n            raise RuntimeError(\n                f\"Expected to find a ClassTypeHint in the base classes of {self!r}, found {current!r} instead.\"\n            )\n\n        response = yield current\n        if response == \"skip\":\n            continue\n\n        current_bases = cast(\n            List[ClassTypeHint],\n            [TypeHint(x, current.type).evaluate().parameterize(current.get_parameter_map()) for x in current.bases],\n        )\n\n        if order == \"bfs\":\n            bases.extend(current_bases)\n        elif order == \"dfs\":\n            bases.extendleft(reversed(current_bases))\n        else:\n            raise ValueError(f\"Invalid order {order!r}\")\n</code></pre>"},{"location":"api/typeapi/#typeapi.ForwardRefTypeHint","title":"ForwardRefTypeHint","text":"<p>             Bases: <code>TypeHint</code></p> <p>Represents a forward reference, i.e. a string in the type annotation or an explicit <code>ForwardRef</code>.</p> Source code in <code>typeapi/typehint.py</code> <pre><code>class ForwardRefTypeHint(TypeHint):\n    \"\"\"Represents a forward reference, i.e. a string in the type annotation or an explicit `ForwardRef`.\"\"\"\n\n    def __init__(self, hint: object, source: \"Any | None\") -&gt; None:\n        super().__init__(hint, source)\n        if isinstance(self._hint, str):\n            self._forward_ref = ForwardRef(self._hint)\n        elif isinstance(self._hint, ForwardRef):\n            self._forward_ref = self._hint\n        else:\n            raise TypeError(\n                f\"ForwardRefTypeHint must be initialized from a typing.ForwardRef or str. Got: {type(self._hint)!r}\"\n            )\n\n    def parameterize(self, parameter_map: Mapping[object, Any]) -&gt; TypeHint:\n        raise RuntimeError(\n            \"ForwardRef cannot be parameterized. Ensure that your type hint is fully \"\n            \"evaluated before parameterization.\"\n        )\n\n    def evaluate(self, context: \"HasGetitem[str, Any] | None\" = None) -&gt; TypeHint:\n        from .future.fake import FakeProvider\n\n        if context is None:\n            context = self.get_context()\n\n        hint = FakeProvider(context).execute(self.expr).evaluate()\n        return TypeHint(hint).evaluate(context)\n\n    @property\n    def hint(self) -&gt; \"ForwardRef | str\":\n        \"\"\"Returns the original type hint.\"\"\"\n        return self._hint  # type: ignore\n\n    @property\n    def ref(self) -&gt; ForwardRef:\n        \"\"\"Same as `hint`, but returns it as a `ForwardRef` always.\"\"\"\n        return self._forward_ref\n\n    @property\n    def expr(self) -&gt; str:\n        \"\"\"\n        Returns the expression of the forward reference.\n\n            &gt;&gt;&gt; TypeHint(ForwardRef(\"Foobar\")).expr\n            'Foobar'\n            &gt;&gt;&gt; TypeHint(TypeHint(List[\"Foobar\"]).args[0]).expr\n            'Foobar'\n        \"\"\"\n\n        return self._forward_ref.__forward_arg__\n</code></pre>"},{"location":"api/typeapi/#typeapi.ForwardRefTypeHint.expr","title":"expr  <code>property</code>","text":"<pre><code>expr: str\n</code></pre> <p>Returns the expression of the forward reference.</p> <pre><code>&gt;&gt;&gt; TypeHint(ForwardRef(\"Foobar\")).expr\n'Foobar'\n&gt;&gt;&gt; TypeHint(TypeHint(List[\"Foobar\"]).args[0]).expr\n'Foobar'\n</code></pre>"},{"location":"api/typeapi/#typeapi.ForwardRefTypeHint.hint","title":"hint  <code>property</code>","text":"<pre><code>hint: ForwardRef | str\n</code></pre> <p>Returns the original type hint.</p>"},{"location":"api/typeapi/#typeapi.ForwardRefTypeHint.ref","title":"ref  <code>property</code>","text":"<pre><code>ref: ForwardRef\n</code></pre> <p>Same as <code>hint</code>, but returns it as a <code>ForwardRef</code> always.</p>"},{"location":"api/typeapi/#typeapi.LiteralTypeHint","title":"LiteralTypeHint","text":"<p>             Bases: <code>TypeHint</code></p> <p>Represents a literal type hint, e.g. <code>Literal[\"a\", 42]</code>.</p> Source code in <code>typeapi/typehint.py</code> <pre><code>class LiteralTypeHint(TypeHint):\n    \"\"\"Represents a literal type hint, e.g. `Literal[\"a\", 42]`.\"\"\"\n\n    @property\n    def args(self) -&gt; Tuple[Any, ...]:\n        return ()\n\n    def parameterize(self, parameter_map: Mapping[object, Any]) -&gt; \"TypeHint\":\n        return self\n\n    def __len__(self) -&gt; int:\n        return 0\n\n    @property\n    def values(self) -&gt; Tuple[Any, ...]:\n        \"\"\"\n        Returns the values of the literal.\n\n            &gt;&gt;&gt; TypeHint(Literal[\"a\", 42]).values\n            ('a', 42)\n        \"\"\"\n\n        return self._args\n</code></pre>"},{"location":"api/typeapi/#typeapi.LiteralTypeHint.values","title":"values  <code>property</code>","text":"<pre><code>values: Tuple[Any, ...]\n</code></pre> <p>Returns the values of the literal.</p> <pre><code>&gt;&gt;&gt; TypeHint(Literal[\"a\", 42]).values\n('a', 42)\n</code></pre>"},{"location":"api/typeapi/#typeapi.TupleTypeHint","title":"TupleTypeHint","text":"<p>             Bases: <code>ClassTypeHint</code></p> <p>A special class to represent a type hint for a parameterized tuple. This class does not represent a plain tuple type without parameterization.</p> Source code in <code>typeapi/typehint.py</code> <pre><code>class TupleTypeHint(ClassTypeHint):\n    \"\"\"\n    A special class to represent a type hint for a parameterized tuple. This class does not represent a plain tuple\n    type without parameterization.\n    \"\"\"\n\n    def __init__(self, hint: object, source: \"Any | None\") -&gt; None:\n        super().__init__(hint, source)\n        if self._args == ((),):\n            self._args = ()\n        elif self._args == () and self._hint == tuple:\n            raise ValueError(\"TupleTypeHint can only represent a parameterized tuple.\")\n        if ... in self._args:\n            assert self._args[-1] == ..., \"Tuple Ellipsis not as last arg\"\n            assert len(self._args) == 2, \"Tuple with Ellipsis has more than two args\"\n            self._repeated = True\n            self._args = self._args[:-1]\n        else:\n            self._repeated = False\n\n    def _copy_with_args(self, args: \"Tuple[Any, ...]\") -&gt; \"TypeHint\":\n        if self._repeated:\n            args = args + (...,)\n        return super()._copy_with_args(args)\n\n    @property\n    def type(self) -&gt; type:\n        return tuple\n\n    @property\n    def repeated(self) -&gt; bool:\n        \"\"\"\n        Returns `True` if the Tuple is of arbitrary length, but only of one type.\n        \"\"\"\n\n        return self._repeated\n</code></pre>"},{"location":"api/typeapi/#typeapi.TupleTypeHint.repeated","title":"repeated  <code>property</code>","text":"<pre><code>repeated: bool\n</code></pre> <p>Returns <code>True</code> if the Tuple is of arbitrary length, but only of one type.</p>"},{"location":"api/typeapi/#typeapi.TypeHint","title":"TypeHint","text":"<p>             Bases: <code>object</code></p> <p>Base class that provides an object-oriented interface to a Python type hint.</p> Source code in <code>typeapi/typehint.py</code> <pre><code>class TypeHint(object, metaclass=_TypeHintMeta):\n    \"\"\"\n    Base class that provides an object-oriented interface to a Python type hint.\n    \"\"\"\n\n    def __init__(self, hint: object, source: \"Any | None\" = None) -&gt; None:\n        self._hint = hint\n        self._origin = get_type_hint_origin_or_none(hint)\n        self._args = get_type_hint_args(hint)\n        self._parameters = get_type_hint_parameters(hint)\n        self._source = source\n\n    def __repr__(self) -&gt; str:\n        return f\"TypeHint({type_repr(self._hint)})\"\n\n    @property\n    def hint(self) -&gt; object:\n        \"\"\"\n        The original type hint.\n        \"\"\"\n\n        return self._hint\n\n    @property\n    def origin(self) -&gt; \"object | None\":\n        \"\"\"\n        The original type behind a type hint (e.g. the `Generic.__origin__`). For example, for :class:`typing.List`,\n        it is `list`. For :class:`typing.Sequence`, it is :class:`collections.abc.Sequence`.\n        \"\"\"\n\n        return self._origin\n\n    @property\n    def args(self) -&gt; Tuple[Any, ...]:\n        \"\"\"\n        Type hint arguments are the values passed into type hint subscripts, e.g. in `Union[int, str]`, the\n        arguments are `(int, str)`. We only return arguments that are expected to be types or other type hints.\n        For example, `Literal[\"foo\", 0]` has an empty tuple for its `args`, and instead the values can be\n        retrievd using :attr:`LiteralTypeHint.valuse`.\n        \"\"\"\n\n        return self._args\n\n    @property\n    def parameters(self) -&gt; Tuple[Any, ...]:\n        \"\"\"\n        The parameters of a type hint is basically :attr:`args` but filtered for #typing.TypeVar objects.\n        \"\"\"\n\n        return self._parameters\n\n    @property\n    def source(self) -&gt; \"Any | None\":\n        \"\"\"\n        The object from which on which the type hint was found, for example a class or a function.\n        \"\"\"\n\n        return self._source\n\n    def __eq__(self, other: object) -&gt; bool:\n        if type(self) != type(other):\n            return False\n        assert isinstance(other, TypeHint)\n        return (self.hint, self.origin, self.args, self.parameters) == (\n            other.hint,\n            other.origin,\n            other.args,\n            other.parameters,\n        )\n\n    def __iter__(self) -&gt; Iterator[\"TypeHint\"]:\n        for i in range(len(self.args)):\n            yield self[i]\n\n    def __len__(self) -&gt; int:\n        return len(self.args)\n\n    @overload\n    def __getitem__(self, __index: int) -&gt; \"TypeHint\": ...\n\n    @overload\n    def __getitem__(self, __slice: slice) -&gt; List[\"TypeHint\"]: ...\n\n    def __getitem__(self, index: \"int | slice\") -&gt; \"TypeHint | List[TypeHint]\":\n        if isinstance(index, int):\n            try:\n                return TypeHint(self.args[index])\n            except IndexError:\n                raise IndexError(f\"TypeHint index {index} out of range [0..{len(self.args)}[\")\n        else:\n            return [TypeHint(x) for x in self.args[index]]\n\n    def _copy_with_args(self, args: \"Tuple[Any, ...]\") -&gt; \"TypeHint\":\n        \"\"\"\n        Internal. Create a copy of this type hint with updated type arguments.\n        \"\"\"\n\n        generic = get_subscriptable_type_hint_from_origin(self.origin)\n        try:\n            new_hint = generic[args]\n        except TypeError as exc:\n            raise TypeError(f\"{type_repr(generic)}: {exc}\")\n        return TypeHint(new_hint)\n\n    def parameterize(self, parameter_map: Mapping[object, Any]) -&gt; \"TypeHint\":\n        \"\"\"\n        Replace references to the type variables in the keys of *parameter_map*\n        with the type hints of the associated values.\n\n        :param parameter_map: A dictionary that maps :class:`TypeVar` to other\n            type hints.\n        \"\"\"\n\n        if self.origin is not None and self.args:\n            args = tuple(TypeHint(x).parameterize(parameter_map).hint for x in self.args)\n            return self._copy_with_args(args)\n        else:\n            return self\n\n    def evaluate(self, context: \"HasGetitem[str, Any] | None\" = None) -&gt; \"TypeHint\":\n        \"\"\"\n        Evaluate forward references in the type hint using the given *context*.\n\n        This method supports evaluating forward references that use PEP585 and PEP604 syntax even in older\n        versions of Python that do not support the PEPs.\n\n        :param context: An object that supports `__getitem__()` to retrieve a value by name. If this is\n            not specified, the globals of the `__module__` of the type hint's source :attr:`source` is\n            used instead. If no source exists, a :class:`RuntimeError` is raised.\n        \"\"\"\n\n        if context is None:\n            context = self.get_context()\n\n        if self.origin is not None and self.args:\n            args = tuple(TypeHint(x).evaluate(context).hint for x in self.args)\n            return self._copy_with_args(args)\n        else:\n            return self\n\n    def get_context(self) -&gt; HasGetitem[str, Any]:\n        \"\"\"Return the context for this type hint in which forward references must be evaluated.\n\n        The context is derived from the `source` attribute, which can be either a `ModuleType`, `Mapping` or\n        `type`. In case of a `type`, the context is composed of the class scope (to resolve class-level members)\n        and the scope of the module that contains the type (looked up in `sys.modules`).\n\n        Raises RuntimeError: If `source` is `None` or has not one of the three supported types.\n        \"\"\"\n\n        if self.source is None:\n            raise RuntimeError(\n                f\"Missing context for {self}.evaluate(), the type hint has no `.source` \"\n                \"to which we could fall back to. Specify the `context` argument or make sure that the type \"\n                \"hint's `.source` is set.\"\n            )\n        if isinstance(self.source, ModuleType):\n            return vars(self.source)\n        if isinstance(self.source, Mapping):\n            return self.source\n        if isinstance(self.source, type):\n            return ChainMap(\n                cast(MutableMapping[str, Any], vars(self.source)),\n                cast(MutableMapping[str, Any], vars(sys.modules[self.source.__module__])),\n            )\n        raise RuntimeError(f\"Unable to determine TypeHint.source context from source={self.source!r}\")\n</code></pre>"},{"location":"api/typeapi/#typeapi.TypeHint.args","title":"args  <code>property</code>","text":"<pre><code>args: Tuple[Any, ...]\n</code></pre> <p>Type hint arguments are the values passed into type hint subscripts, e.g. in <code>Union[int, str]</code>, the arguments are <code>(int, str)</code>. We only return arguments that are expected to be types or other type hints. For example, <code>Literal[\"foo\", 0]</code> has an empty tuple for its <code>args</code>, and instead the values can be retrievd using :attr:<code>LiteralTypeHint.valuse</code>.</p>"},{"location":"api/typeapi/#typeapi.TypeHint.hint","title":"hint  <code>property</code>","text":"<pre><code>hint: object\n</code></pre> <p>The original type hint.</p>"},{"location":"api/typeapi/#typeapi.TypeHint.origin","title":"origin  <code>property</code>","text":"<pre><code>origin: object | None\n</code></pre> <p>The original type behind a type hint (e.g. the <code>Generic.__origin__</code>). For example, for :class:<code>typing.List</code>, it is <code>list</code>. For :class:<code>typing.Sequence</code>, it is :class:<code>collections.abc.Sequence</code>.</p>"},{"location":"api/typeapi/#typeapi.TypeHint.parameters","title":"parameters  <code>property</code>","text":"<pre><code>parameters: Tuple[Any, ...]\n</code></pre> <p>The parameters of a type hint is basically :attr:<code>args</code> but filtered for #typing.TypeVar objects.</p>"},{"location":"api/typeapi/#typeapi.TypeHint.source","title":"source  <code>property</code>","text":"<pre><code>source: Any | None\n</code></pre> <p>The object from which on which the type hint was found, for example a class or a function.</p>"},{"location":"api/typeapi/#typeapi.TypeHint.evaluate","title":"evaluate","text":"<pre><code>evaluate(context: HasGetitem[str, Any] | None = None) -&gt; TypeHint\n</code></pre> <p>Evaluate forward references in the type hint using the given context.</p> <p>This method supports evaluating forward references that use PEP585 and PEP604 syntax even in older versions of Python that do not support the PEPs.</p> <p>:param context: An object that supports <code>__getitem__()</code> to retrieve a value by name. If this is     not specified, the globals of the <code>__module__</code> of the type hint's source :attr:<code>source</code> is     used instead. If no source exists, a :class:<code>RuntimeError</code> is raised.</p> Source code in <code>typeapi/typehint.py</code> <pre><code>def evaluate(self, context: \"HasGetitem[str, Any] | None\" = None) -&gt; \"TypeHint\":\n    \"\"\"\n    Evaluate forward references in the type hint using the given *context*.\n\n    This method supports evaluating forward references that use PEP585 and PEP604 syntax even in older\n    versions of Python that do not support the PEPs.\n\n    :param context: An object that supports `__getitem__()` to retrieve a value by name. If this is\n        not specified, the globals of the `__module__` of the type hint's source :attr:`source` is\n        used instead. If no source exists, a :class:`RuntimeError` is raised.\n    \"\"\"\n\n    if context is None:\n        context = self.get_context()\n\n    if self.origin is not None and self.args:\n        args = tuple(TypeHint(x).evaluate(context).hint for x in self.args)\n        return self._copy_with_args(args)\n    else:\n        return self\n</code></pre>"},{"location":"api/typeapi/#typeapi.TypeHint.get_context","title":"get_context","text":"<pre><code>get_context() -&gt; HasGetitem[str, Any]\n</code></pre> <p>Return the context for this type hint in which forward references must be evaluated.</p> <p>The context is derived from the <code>source</code> attribute, which can be either a <code>ModuleType</code>, <code>Mapping</code> or <code>type</code>. In case of a <code>type</code>, the context is composed of the class scope (to resolve class-level members) and the scope of the module that contains the type (looked up in <code>sys.modules</code>).</p> <p>Raises RuntimeError: If <code>source</code> is <code>None</code> or has not one of the three supported types.</p> Source code in <code>typeapi/typehint.py</code> <pre><code>def get_context(self) -&gt; HasGetitem[str, Any]:\n    \"\"\"Return the context for this type hint in which forward references must be evaluated.\n\n    The context is derived from the `source` attribute, which can be either a `ModuleType`, `Mapping` or\n    `type`. In case of a `type`, the context is composed of the class scope (to resolve class-level members)\n    and the scope of the module that contains the type (looked up in `sys.modules`).\n\n    Raises RuntimeError: If `source` is `None` or has not one of the three supported types.\n    \"\"\"\n\n    if self.source is None:\n        raise RuntimeError(\n            f\"Missing context for {self}.evaluate(), the type hint has no `.source` \"\n            \"to which we could fall back to. Specify the `context` argument or make sure that the type \"\n            \"hint's `.source` is set.\"\n        )\n    if isinstance(self.source, ModuleType):\n        return vars(self.source)\n    if isinstance(self.source, Mapping):\n        return self.source\n    if isinstance(self.source, type):\n        return ChainMap(\n            cast(MutableMapping[str, Any], vars(self.source)),\n            cast(MutableMapping[str, Any], vars(sys.modules[self.source.__module__])),\n        )\n    raise RuntimeError(f\"Unable to determine TypeHint.source context from source={self.source!r}\")\n</code></pre>"},{"location":"api/typeapi/#typeapi.TypeHint.parameterize","title":"parameterize","text":"<pre><code>parameterize(parameter_map: Mapping[object, Any]) -&gt; TypeHint\n</code></pre> <p>Replace references to the type variables in the keys of parameter_map with the type hints of the associated values.</p> <p>:param parameter_map: A dictionary that maps :class:<code>TypeVar</code> to other     type hints.</p> Source code in <code>typeapi/typehint.py</code> <pre><code>def parameterize(self, parameter_map: Mapping[object, Any]) -&gt; \"TypeHint\":\n    \"\"\"\n    Replace references to the type variables in the keys of *parameter_map*\n    with the type hints of the associated values.\n\n    :param parameter_map: A dictionary that maps :class:`TypeVar` to other\n        type hints.\n    \"\"\"\n\n    if self.origin is not None and self.args:\n        args = tuple(TypeHint(x).parameterize(parameter_map).hint for x in self.args)\n        return self._copy_with_args(args)\n    else:\n        return self\n</code></pre>"},{"location":"api/typeapi/#typeapi.TypeVarTypeHint","title":"TypeVarTypeHint","text":"<p>             Bases: <code>TypeHint</code></p> <p>Represents a <code>TypeVar</code> type hint.</p> Source code in <code>typeapi/typehint.py</code> <pre><code>class TypeVarTypeHint(TypeHint):\n    \"\"\"Represents a `TypeVar` type hint.\"\"\"\n\n    @property\n    def hint(self) -&gt; TypeVar:\n        assert isinstance(self._hint, TypeVar)\n        return self._hint\n\n    def parameterize(self, parameter_map: Mapping[object, Any]) -&gt; \"TypeHint\":\n        return TypeHint(parameter_map.get(self.hint, self.hint))\n\n    def evaluate(self, context: \"HasGetitem[str, Any] | None\" = None) -&gt; TypeHint:\n        return self\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Returns the name of the type variable.\n\n            &gt;&gt;&gt; TypeHint(TypeVar(\"T\")).name\n            'T'\n        \"\"\"\n\n        return self.hint.__name__\n\n    @property\n    def covariant(self) -&gt; bool:\n        \"\"\"\n        Returns whether the TypeVar is covariant.\n\n            &gt;&gt;&gt; TypeHint(TypeVar(\"T\")).covariant\n            False\n            &gt;&gt;&gt; TypeHint(TypeVar(\"T\", covariant=True)).covariant\n            True\n        \"\"\"\n\n        return self.hint.__covariant__\n\n    @property\n    def contravariant(self) -&gt; bool:\n        \"\"\"\n        Returns whether the TypeVar is contravariant.\n\n            &gt;&gt;&gt; TypeHint(TypeVar(\"T\")).contravariant\n            False\n            &gt;&gt;&gt; TypeHint(TypeVar(\"T\", contravariant=True)).contravariant\n            True\n        \"\"\"\n\n        return self.hint.__contravariant__\n\n    @property\n    def constraints(self) -&gt; \"Tuple[Any, ...]\":\n        \"\"\"\n        Returns the constraints of the TypeVar.\n\n            &gt;&gt;&gt; TypeHint(TypeVar(\"T\", int, str)).constraints\n            (&lt;class 'int'&gt;, &lt;class 'str'&gt;)\n        \"\"\"\n\n        return self.hint.__constraints__\n\n    @property\n    def bound(self) -&gt; Any:\n        \"\"\"\n        Returns what the TypeVar is bound to.\n\n            &gt;&gt;&gt; TypeHint(TypeVar(\"T\", bound=str)).bound\n            &lt;class 'str'&gt;\n        \"\"\"\n\n        return self.hint.__bound__\n</code></pre>"},{"location":"api/typeapi/#typeapi.TypeVarTypeHint.bound","title":"bound  <code>property</code>","text":"<pre><code>bound: Any\n</code></pre> <p>Returns what the TypeVar is bound to.</p> <pre><code>&gt;&gt;&gt; TypeHint(TypeVar(\"T\", bound=str)).bound\n&lt;class 'str'&gt;\n</code></pre>"},{"location":"api/typeapi/#typeapi.TypeVarTypeHint.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Tuple[Any, ...]\n</code></pre> <p>Returns the constraints of the TypeVar.</p> <pre><code>&gt;&gt;&gt; TypeHint(TypeVar(\"T\", int, str)).constraints\n(&lt;class 'int'&gt;, &lt;class 'str'&gt;)\n</code></pre>"},{"location":"api/typeapi/#typeapi.TypeVarTypeHint.contravariant","title":"contravariant  <code>property</code>","text":"<pre><code>contravariant: bool\n</code></pre> <p>Returns whether the TypeVar is contravariant.</p> <pre><code>&gt;&gt;&gt; TypeHint(TypeVar(\"T\")).contravariant\nFalse\n&gt;&gt;&gt; TypeHint(TypeVar(\"T\", contravariant=True)).contravariant\nTrue\n</code></pre>"},{"location":"api/typeapi/#typeapi.TypeVarTypeHint.covariant","title":"covariant  <code>property</code>","text":"<pre><code>covariant: bool\n</code></pre> <p>Returns whether the TypeVar is covariant.</p> <pre><code>&gt;&gt;&gt; TypeHint(TypeVar(\"T\")).covariant\nFalse\n&gt;&gt;&gt; TypeHint(TypeVar(\"T\", covariant=True)).covariant\nTrue\n</code></pre>"},{"location":"api/typeapi/#typeapi.TypeVarTypeHint.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Returns the name of the type variable.</p> <pre><code>&gt;&gt;&gt; TypeHint(TypeVar(\"T\")).name\n'T'\n</code></pre>"},{"location":"api/typeapi/#typeapi.UnionTypeHint","title":"UnionTypeHint","text":"<p>             Bases: <code>TypeHint</code></p> <p>Represents a union of types, e.g. <code>typing.Union[A, B]</code> or <code>A | B</code>.</p> Source code in <code>typeapi/typehint.py</code> <pre><code>class UnionTypeHint(TypeHint):\n    \"\"\"Represents a union of types, e.g. `typing.Union[A, B]` or `A | B`.\"\"\"\n\n    def has_none_type(self) -&gt; bool:\n        return NoneType in self._args\n\n    def without_none_type(self) -&gt; TypeHint:\n        args = tuple(x for x in self._args if x is not NoneType)\n        if len(args) == 1:\n            return TypeHint(args[0])\n        else:\n            return self._copy_with_args(args)\n</code></pre>"},{"location":"api/typeapi/#typeapi.get_annotations","title":"get_annotations","text":"<pre><code>get_annotations(obj: Union[Callable[..., Any], ModuleType, type], include_bases: bool = False, globalns: Optional[Dict[str, Any]] = None, localns: Optional[Dict[str, Any]] = None, eval_str: bool = True) -&gt; Dict[str, Any]\n</code></pre> <p>Like #typing.get_type_hints(), but always includes extras. This is important when we want to inspect</p>"},{"location":"api/typeapi/#typeapi.get_annotations--typingannotated-hints-without-extras-the-annotations-are-removed-in-python-310-and-onwards-this-is","title":"typing.Annotated hints (without extras the annotations are removed). In Python 3.10 and onwards, this is","text":"<p>an alias for #inspect.get_annotations() with <code>eval_str=True</code>.</p> <p>If include_bases is set to <code>True</code>, annotations from base classes are taken into account as well.</p> <p>This function will take into account the locals and globals accessible through the frame associated with a function or type by the #scoped() decorator.</p> Source code in <code>typeapi/utils.py</code> <pre><code>def get_annotations(\n    obj: Union[Callable[..., Any], ModuleType, type],\n    include_bases: bool = False,\n    globalns: Optional[Dict[str, Any]] = None,\n    localns: Optional[Dict[str, Any]] = None,\n    eval_str: bool = True,\n) -&gt; Dict[str, Any]:\n    \"\"\"Like #typing.get_type_hints(), but always includes extras. This is important when we want to inspect\n    #typing.Annotated hints (without extras the annotations are removed). In Python 3.10 and onwards, this is\n    an alias for #inspect.get_annotations() with `eval_str=True`.\n\n    If *include_bases* is set to `True`, annotations from base classes are taken into account as well.\n\n    This function will take into account the locals and globals accessible through the frame associated with\n    a function or type by the #scoped() decorator.\"\"\"\n\n    if hasattr(obj, \"__typeapi_frame__\"):\n        frame: FrameType = obj.__typeapi_frame__  # type: ignore[union-attr]\n        globalns = frame.f_globals\n        localns = frame.f_locals\n        del frame\n\n    elif hasattr(obj, \"__module__\"):\n        module = sys.modules.get(obj.__module__)\n        if module is None:\n            warnings.warn(\n                f\"sys.modules[{obj.__module__!r}] does not exist, type hint resolution context for object of type \"\n                f\"{type(obj).__name__!r} will not be available.\",\n                UserWarning,\n            )\n        else:\n            assert hasattr(module, \"__dict__\"), module\n            globalns = vars(module)\n\n    from collections import ChainMap\n\n    from .typehint import TypeHint\n\n    def eval_callback(hint_expr: str, globals: Any, locals: Any) -&gt; Any:\n        chainmap = ChainMap(locals or {}, globals or {})\n        if isinstance(obj, type):\n            chainmap = chainmap.new_child(cast(MutableMapping[str, Any], vars(obj)))\n        hint = TypeHint(hint_expr, chainmap)\n        return hint.evaluate().hint\n\n    annotations = _inspect_get_annotations(obj, globals=globalns, locals=localns, eval_str=eval_str, eval=eval_callback)\n\n    if isinstance(obj, type) and include_bases:\n        annotations = {}\n        for base in obj.__mro__:\n            base_annotations = _inspect_get_annotations(\n                base, globals=globalns, locals=localns, eval_str=eval_str, eval=eval_callback\n            )\n            annotations.update({k: v for k, v in base_annotations.items() if k not in annotations})\n\n    return annotations\n</code></pre>"},{"location":"api/typeapi/#typeapi.is_typed_dict","title":"is_typed_dict","text":"<pre><code>is_typed_dict(hint: Any) -&gt; TypeGuard[TypedDictProtocol]\n</code></pre> <p>Returns:</p> Type Description <code>TypeGuard[TypedDictProtocol]</code> <p><code>True</code> if hint is a #typing.TypedDict.</p> <p>Note</p> <p>Typed dictionaries are actually just type objects. This means #typeapi.of() will represent them as</p> Source code in <code>typeapi/utils.py</code> <pre><code>def is_typed_dict(hint: Any) -&gt; TypeGuard[TypedDictProtocol]:\n    \"\"\"\n    Returns:\n        `True` if *hint* is a #typing.TypedDict.\n\n    !!! note\n\n        Typed dictionaries are actually just type objects. This means #typeapi.of() will represent them as\n        #typeapi.models.Type.\n    \"\"\"\n\n    import typing\n\n    import typing_extensions\n\n    for m in (typing, typing_extensions):\n        if hasattr(m, \"_TypedDictMeta\") and isinstance(hint, m._TypedDictMeta):  # type: ignore[attr-defined]\n            return True\n    return False\n</code></pre>"},{"location":"api/typeapi/#typeapi.is_typed_dict--typeapimodelstype","title":"typeapi.models.Type.","text":""},{"location":"api/typeapi/#typeapi.type_repr","title":"type_repr","text":"<pre><code>type_repr(obj: Any) -&gt; str\n</code></pre>"},{"location":"api/typeapi/#typeapi.type_repr--typing_type_repr-stolen-from-python-38","title":"typing._type_repr() stolen from Python 3.8.","text":"Source code in <code>typeapi/utils.py</code> <pre><code>def type_repr(obj: Any) -&gt; str:\n    \"\"\"#typing._type_repr() stolen from Python 3.8.\"\"\"\n\n    if (getattr(obj, \"__module__\", None) or getattr(type(obj), \"__module__\", None)) in TYPING_MODULE_NAMES or hasattr(\n        obj, \"__args__\"\n    ):\n        # NOTE(NiklasRosenstein): In Python 3.6, List[int] is actually a \"type\" subclass so we can't\n        #       rely on the fall through on the below.\n        return repr(obj)\n\n    if isinstance(obj, type):\n        if obj.__module__ == \"builtins\":\n            return obj.__qualname__\n        return f\"{obj.__module__}.{obj.__qualname__}\"\n    if obj is ...:\n        return \"...\"\n    if isinstance(obj, FunctionType):\n        return obj.__name__\n    return repr(obj)\n</code></pre>"}]}